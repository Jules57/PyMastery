# Урок 18. Exceptions.

![](https://cdn.buttercms.com/LUta2G5oQ0iKH4DLd6jm)

Что вы предпринимаете, когда с работой вашей программы что-то идет не так? Допустим, вы пытаетесь открыть файл, но вы 
ввели неверный путь, или вы хотите узнать информацию у пользователей, и они пишут какую-то бессмыслицу. Вы не хотите, 
чтобы ваша программа завершалась с ошибкой, поэтому вы выполняете обработку исключений. В Python, конструкция всегда 
обернута в то, что называется try/except.

Иерархия исключений выглядит вот так:

![](https://w3.cs.jmu.edu/lam2mo/cs240_2014_08/images/exception_hierarchy.png)

Начнем со знакомства с самыми обычными исключениями, которые вы увидите в Python. Обратите внимание на то, что ошибка и
исключение – два разных слова, описывающих одно и то же в контексте обработки исключений.

## Основные исключения

Ниже изложен список основных встроенных исключений (определение в документации к Python):

`Exception` – то, на чем фактически строятся все остальные ошибки;

`AttributeError` – возникает, когда ссылка атрибута или присвоение не могут быть выполнены;

`IOError` – возникает в том случае, когда операция I/O (например, оператор вывода, встроенная функция `open()` или метод 
объекта-файла) не может быть выполнена, по связанной с I/O причине: «файл не найден», или «диск заполнен», 
иными словами.

`ImportError` – возникает, когда оператор `import` не может найти определение модуля, или когда оператор не может найти 
имя файла, который должен быть импортирован;

`IndexError` – возникает, когда индекс последовательности находится вне допустимого диапазона;

`KeyError` – возникает, когда ключ сопоставления (dictionary key) не найден в наборе существующих ключей;

`KeyboardInterrupt` – возникает, когда пользователь нажимает клавишу прерывания (обычно `Delete` или `Ctrl+C`);

`NameError` – возникает, когда локальное или глобальное имя не найдено;

`OSError` – возникает, когда функция получает связанную с системой ошибку;

`SyntaxError` — возникает, когда синтаксическая ошибка встречается синтаксическим анализатором;

`TypeError` – возникает, когда операция или функция применяется к объекту несоответствующего типа. Связанное значение 
представляет собой строку, в которой приводятся подробные сведения о несоответствии типов;

`ValueError` – возникает, когда встроенная операция или функция получают аргумент, тип которого правильный, но 
неправильно значение, и ситуация не может быть описана более точно, как при возникновении `IndexError`;

`ZeroDivisionError` – возникает, когда второй аргумент операции division или modulo равен нулю;

Существует много других исключений, но вы вряд ли будете сталкиваться с ними так же часто.

### Как обрабатывать исключения?

Обработка исключений в Python – это очень просто. Потратим немного времени и напишем несколько примеров, которые их 
вызовут. Мы начнем с одной из самых элементарных проблем: деление на ноль.

```python
1 / 0
```
```python
Traceback (most recent call last):
    File "<string>", line 1, in <fragment>
ZeroDivisionError: integer division or modulo by zero
```

```python
try:
    1 / 0
except ZeroDivisionError:
    print("You cannot divide by zero!")

```
```python
>>> You cannot divide by zero!
```

Если мы обратимся к урокам элементарной математики, то вспомним, что на ноль делить нельзя. В Python данная операция 
вызовет ошибку, как мы можем видеть в примере выше. Чтобы поймать ошибку, мы завернем операцию в оператор try/except.

### «Голое» исключение

Есть еще один способ поймать ошибку:

```python
try:
    1 / 0
except:
    print("You cannot divide by zero!")
# ЭТО СРАБОТАЕТ, НО ТАК ДЕЛАТЬ НЕЛЬЗЯ
```

На жаргоне Python это известно как голое исключение, что означает, что будут найдены вообще все исключения. Причина,
по которой так делать не рекомендуется, заключается в том, что вы не узнаете, что именно за исключение вы выловите. 
Когда у вас возникло что-то в духе `ZeroDivisionError`, вы хотите выявить фрагмент, в котором происходит деление на 
ноль. В написанном выше коде вы не можете указать, что именно вам нужно выявить. Давайте взглянем еще на несколько 
примеров:

```python
my_dict = {"a": 1, "b": 2, "c": 3}

try:
    value = my_dict["d"]
except KeyError:
    print("Thе key does not exist!")

```
```python
my_list = [1, 2, 3, 4, 5]

try:
    my_list[6]
except IndexError:
    print("That index is not in the list!")
```

В первом примере мы создали словарь из трех элементов. После этого мы попытались открыть доступ к ключу, которого в 
словаре нет. Так как ключа нет в словаре, возникает ошибка `KeyError`, которую мы выявили. Второй пример показывает 
список, длина которого составляет пять элементов. Мы попытались взять седьмой элемент из индекса.

Помните, что списки в Python начинаются с нуля, так что когда вы говорите 6, вы запрашиваете 7. В любом случае в нашем 
списке только пять объектов, по этой причине возникает `IndexError`, которую мы выявили. Вы также можете выявить 
несколько ошибок за раз при помощи одного оператора. Для этого существует несколько различных способов. 
Давайте посмотрим:

```python
my_dict = {"a": 1, "b": 2, "c": 3}

try:
    value = my_dict["d"]
except IndexError:
    print("This index does not exist!")
except KeyError:
    print("This key is not in the dictionary!")
except:
    print("Some other error occurred!")
```

Это самый стандартный способ выявить несколько исключений. Сначала мы попробовали открыть доступ к несуществующему 
ключу, которого нет в нашем словаре. При помощи `try/except` мы проверили код на наличие ошибки `KeyError`, которая 
находится во втором операторе `except`. Обратите внимание на то, что в конце кода у нас появилась «голое» исключение. 
Обычно это не рекомендуется, но вы, возможно, будете сталкиваться с этим время от времени, так что лучше быть 
проинформированным об этом. Кстати, также обратите внимание на то, что вам не нужно использовать целый блок кода для 
обработки нескольких исключений. Обычно, целый блок используется для выявления одного единственного исключения. 

Изучим второй способ выявления нескольких исключений:

```python
try:
    value = my_dict["d"]
except IndexError, KeyError:
    print("An IndexError or KeyError occurred!")
```

Обратите внимание на то, что в данном примере мы помещаем ошибки, которые мы хотим выявить, внутри круглых скобок. 
Проблема данного метода в том, что трудно сказать, какая именно ошибка произошла, так что предыдущий пример, мы 
рекомендуем больше, чем этот. Зачастую, когда происходит ошибка, вам нужно уведомить пользователя, при помощи сообщения.

В зависимости от сложности данной ошибки вам может понадобиться выйти из программы. Иногда вам может понадобиться 
выполнить очистку перед выходом из программы. Например, если вы открыли соединение с базой данных, вам нужно будет 
закрыть его перед выходом из программы, или вы можете закончить с открытым соединением. Другой пример – закрытие 
дескриптора файла, к которому вы обращаетесь. Теперь нам нужно научиться убирать за собой. Это очень просто, если 
использовать оператор `finally`.

## Оператор finally

Оператор `finally` очень прост в использовании. Давайте взглянем на нижеизложенный пример:

```python
my_dict = {"a": 1, "b": 2, "c": 3}

try:
    value = my_dict["d"]
except KeyError:
    print("A KeyError occurred!")
finally:
    print("The finally statement has executed!")
```

Если вы запустите этот код, оно отобразится и в операторе `except`, и в `finally`. Весьма просто, не так ли? Теперь вы 
можете использовать оператор `finally`, чтобы убрать за собой. Вы можете также вписать код `exit` в конце оператора 
`finally`.

Попробуйте `except` или `else`.

Оператор `try/except` также имеет блок `else`. Он работает только в том случае, если в вашем коде нет ни единой ошибки. 
Давайте потратим немного времени и взглянем на парочку примеров:

```python
my_dict = {"a": 1, "b": 2, "c": 3}

try:
    value = my_dict["a"]
except KeyError:
    print("A KeyError occurred!")
else:
    print("No error occurred!")
```

Мы видим словарь, состоящий из трех элементов, и в операторе `try/except` мы открываем доступ к существующему ключу. 
Это работает, так что ошибка `KeyError` не возникает. Так как ошибки нет, `else` работает, и надпись 
“No error occurred!” появляется на экране. Теперь добавим оператор `finally`:

```python
my_dict = {"a": 1, "b": 2, "c": 3}

try:
    value = my_dict["a"]
except KeyError:
    print("A KeyError occurred!")
else:
    print("No error occurred!")
finally:
    print("The finally statement ran!")
```

В данном коде работают и оператор `else`, и `finally`. Большую часть времени вы не будете сталкиваться с оператором 
`else`, используемым в том или ином коде, который следует за оператором `try/except`, если ни одна ошибка не была 
найдена. Единственное полезное применение оператора `else`, которое я видел, — это когда вы хотите запустить вторую 
часть кода, в которой может быть ошибка. Конечно, если ошибка возникает в `else`, то она не будет поймана.

### Оператор raise

Если в вашем коде какие-либо данные не соответствуют вашим ожиданиям, вы всегда можете вызвать исключение, если вам это 
необходимо, для этого используется ключевое слово `raise`.

```python
def even_the_odds(odds):
    if odds % 2 != 1:
        raise ValueError("Did not get an odd number")
    return odds + 1
```

Любое исключение завершает наш код, а значит, что до возврата в случае исключения функция не дойдет.

Мы можем использовать `raise` внутри любой конструкции. Допустим, нам нужно отправлять ошибку на сторонний сервис, но 
не обрабатывать её.

```python
try:
    do_stuff(resource)
except SomeException as e:
    log_error(e)
    raise  # re-raise the error
finally:
    free_expensive_resource(resource)
```

`raise` в этом случае просто повторится.

Еще один такой пример:

```python
 try:
    5 / 0
except ZeroDivisionError:
    print("Got an error")
    raise
```

Имейте в виду, однако, что кто-то еще выше в стеке вызовов может все же перехватить исключение и как-то обработать его.
Готовый вывод может быть неприятным в этом случае, потому что это произойдет в любом случае (пойман или не пойман). 
Поэтому может быть лучше создать другое исключение, содержащее ваш комментарий о ситуации, а также исходное исключение:

```python
try:
    5 / 0
except ZeroDivisionError as e:
    raise ZeroDivisionError("Got an error", e)
```

в переменной `e` будет храниться вся информация об исключении, и таким рейзом мы вызовем нужный нам тип исключения, с 
нашим комментарием и всей системной информацией.

### Исключения тоже объекты

Исключением являются только обычные объекты Python, которые наследуют от встроенного `BaseException`. Сценарий Python 
может использовать `raise` заявление, чтобы прервать выполнение, в результате чего Python для печати трассировки стека 
из стека вызовов в этой точке и представление экземпляра исключения.

Например:

```python
 >>> def failing_function():
...     raise ValueError('Example error!')
>>> failing_function()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in failing_function
ValueError: Example error!
```

Который говорит, что `ValueError` с сообщением 'Example error!' был поднят нашей `failing_function()`, который был 
выполнен в интерпретаторе.

Код вызова может выбрать обработку любых исключений, которые может вызвать вызов:

```python
 >>> try:
...     failing_function()
... except ValueError:
...     print('Handled the error')
Handled the error
```

Или вывести оригинальный текст:

```python
>>> try:
...     failing_function()
... except ValueError as e:
...     print('Caught exception', repr(e))
Caught exception ValueError('Example error!',)
```

## Создание пользовательских типов исключений

Создайте класс, унаследованный от `Exception`:
```python
class FooException(Exception):
    pass

try:
    raise FooException("insert description here")
except FooException:
    print("A FooException was raised.")
```

Или другой тип исключения:

```python
class NegativeError(ValueError):
      pass

def foo(x):
    # function that only accepts positive values of x
    if x < 0:
        raise NegativeError("Cannot process negative numbers")
    ...  # rest of function body

try:
    result = foo(int(input("Enter a positive integer: ")))  # raw_input in Python 2.x
except NegativeError:
    print("You entered a negative number!")
else:
    print("The result was " + str(result))
```
