### Хэш таблицы. Set. Frozenset. 

![](https://preview.redd.it/python-meme-true-v0-g6vhhhsht6b91.jpg?auto=webp&s=21c5fc970b99544bdb2d60b760b112560709030a)

## Хэш таблицы

Для понимания того, как работают следующие типы данных, надо сперва взглянуть на то, как они структурно хранятся.

Для этого нам необходимо познакомиться с некоторыми терминами и понятиями.

**Хэш-таблицы** – это тип структуры данных, в которой адрес или значение индекса элемента данных генерируются из
хеш-функции. Это ускоряет доступ к данным, поскольку значение индекса ведет себя как ключ к значению данных. Другими
словами, в хэш-таблице хранятся пары ключ-значение, но ключ генерируется с помощью функции хеширования.
Таким образом, функция поиска и вставки элемента данных становится намного быстрее, поскольку сами значения ключей
становятся индексом массива, в котором хранятся данные.

### Хэш-функция и хэш-значение

**Хэш-функция** выполняет хэширование, превращая любые данные в последовательность байтов фиксированного размера,
называемую **хэш-значением** или **хэш-кодом**. Это число, которое может служить цифровым отпечатком или дайджестом,
обычно гораздо меньшим, чем исходные данные, что позволяет проверить их целостность. Если вы когда-нибудь брали из
Интернета большой файл, например образ диска с дистрибутивом Linux, то, возможно, заметили на странице загрузки
контрольную сумму MD5 или SHA-2.

Помимо проверки целостности данных и решения проблемы словаря, хэш-функции помогают и в других областях, включая
безопасность и криптографию. Например, вы обычно храните хэшированные пароли в базах данных, чтобы снизить риск утечки
данных. Цифровые подписи используют хэширование для создания дайджеста сообщения перед шифрованием. Транзакции блокчейн

Примечание: Криптографическая хэш-функция - это особый тип хэш-функции, который должен отвечать нескольким
дополнительным требованиям. В рамках нашего курса вы познакомитесь только с самой базовой формой хэш-функции,
используемой в структуре данных хэш-таблицы.

Хотя существует множество алгоритмов хеширования, все они обладают несколькими общими свойствами, которые вы узнаете
в этом разделе. Правильная реализация хорошей хэш-функции - сложная задача, которая может потребовать понимания
продвинутой математики, связанной с простыми числами. К счастью, обычно вам не нужно реализовывать такой алгоритм
вручную.

```python
>>> hash(3.14)
322818021289917443

>>> hash(3.14159265358979323846264338327950288419716939937510)
326490430436040707

>>> hash("Lorem")
7677195529669851635

>>> hash("""Lorem ipsum dolor sit amet, consectetur adipisicing elit,
sed do eiusmod tempor incididunt ut labore et dolore magna
aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit
esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
occaecat cupidatat non proident, sunt in culpa qui officia
deserunt mollit anim id est laborum.""")
1107552240612593693
```

Уже сейчас, глядя на результат, можно сделать несколько наблюдений. Во-первых, встроенная хэш-функция может возвращать
разные значения для некоторых входных данных, показанных выше. В то время как числовой ввод всегда дает одинаковое
хэш-значение, строка, скорее всего, не дает. Почему так происходит? Может показаться, что **hash()** -
недетерминированная функция, но это не может быть дальше от истины!

Когда вы вызываете `hash()` с тем же аргументом в рамках существующей сессии интерпретатора, вы будете получать один и
тот же результат:

```python
>>> hash("Lorem")
7677195529669851635

>>> hash("Lorem")
7677195529669851635

>>> hash("Lorem")
7677195529669851635
```

Это потому, что хэш-значения неизменяемы и не меняются в течение всего времени жизни объекта. Однако, как только вы
выйдете из Python и запустите его снова, вы почти наверняка увидите разные хэш-значения при разных вызовах Python.

Что нам нужно знать про хеш? Нужно знать, что это функция которая преобразовывает данные так, что их невозможно
восстановить, но при этом одни и те же данные всегда превратятся в конкретное значение.

Если ваши данные это кусок мяса, то хеш функция - это мясорубка, которая превратит его в фарш. А фарш, как известно,
невозможно прокрутить назад.

## Выводы

- Хеш-таблицы используют хеш-функцию для преобразования ключей в индексы массива, где хранятся значения. Это позволяет
  обеспечить быстрый доступ к данным по ключу.
- Коллизии: Когда два ключа имеют один и тот же хеш, происходит коллизия. Python решает проблему коллизий с помощью
  метода открытой адресации (в частности квадратичного пробирования) или цепочек (в зависимости от версии Python и
  текущих условий).Что нам не надо париться как это работает под капотом, всё придумали за нас.
- Не все данные можно хэшировать. Все стандартные неизменяемые типы данных являются хэшируемыми, но не все изменяемые
  являются нехэшируемыми (хотя большинство всё-таки нельзя хэшировать).
- Сложность: В среднем время доступа, добавления и удаления элементов составляет O(1). Однако в худшем случае,
  например, когда происходят коллизии, эти операции могут занять O(n) времени.
- В Python функция `hash()` встроена и работает без нашего участия.
- Цифры до определённого размера будут преобразовываться сами в себя, но это нормально, не обращаем внимания.

## Set (Множество)

Наконец к сути.

Первый тип данных основанный на хэш таблицах, - это множество (set).  **Множество (set)** - это объект-контейнер
уникальных значений, который работает как математическое множество.

# Важные особенности множеств:

- Все элементы в множестве должны быть уникальны. Никакие два элемента не могут иметь одинаковые значения. При попытке
  добавить в множество нехэшируемый элемент интерпретатор выдаст ошибку. К нехэшируемым стандартным типам относятся
  список, словарь или другое множество.
- Множества не упорядочены, т. е. элементы в множестве не поддерживают индексацию и срезы.
- Элементы множества могут иметь разные типы данных. При этом все элементы должны быть хэшируемыми.
- Множество - это изменяемая последовательность, следовательно, мы можем добавлять в него элементы, удалять их и искать.

Под капотом сет это хэш таблица, где в качестве значения, записывается само значения объекта. А это значит, что если мы
попытаемся записать в сет дублирующее значение, мы просто перезапишем ту же самую строку хэш таблицы.

# Создание множеств:

Чтобы создать множество, необходимо вызвать встроенную функцию `set()`. Чтобы создать множество с элементами, нужно
заключить их в фигурные скобки и разделить запятыми.

```python
>>> empty_set = set()
# set()

>>> set_from_string = set('hello world')
# {'d', 'l', 'h', 'r', 'e', ' ', 'w', 'o'}

>>> set_from_list = set([1, 2, 3, 4, 5])
# {1, 2, 3, 4, 5}

>>> random_set = {1, 2, 3, 'a', 'c', 0.34}
# {0.34, 1, 2, 3, 'a', 'c'}

>>> incorrect_set = {1, 2, [1, 2]}
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: unhashable type: 'list'
```

В функцию `set()` можно также передать один аргумент. Передаваемый аргумент должен быть объектом, который содержит
итерируемые элементы, такие как список, кортеж или строковое значение. Отдельные элементы объекта, передаваемого в
качестве аргумента, становятся элементами множества. Если в качестве аргумента в функцию set передать строковое
значение, то каждый отдельный символ в строковом значении становится членом множества.

Методы множеств:

| Метод                         |                                                                                           |
|-------------------------------|-------------------------------------------------------------------------------------------|
| add()                         | Добавляет элемент в множество                                                             |
| clear()                       | Удаляет все элементы из множества                                                         |
| copy()                        | Возвращает копию множества                                                                |
| difference()                  | Возвращает множество, содержащее разность между двумя или более множествами               |
| difference_update()           | Удаляет элементы из этого множества, которые также включены в другое, указанное множество |
| discard()                     | Удаляет элемент по значению                                                               |
| intersection()                | Возвращает пересечение двух множеств                                                      |
| intersection_update()         | Удаляет элементы из этого множества, которые присутствуют в другом множестве              |
| isdisjoint()                  | Возвращает, пересекаются ли два множества или нет (True / False)                          |
| issubset()                    | Возвращает, содержит ли другое множество это множество или нет (True / False)             |
| issuperset()                  | Возвращает, содержит ли данное множество другое множество или нет (True / False)          |
| pop()                         | Удаляет элемент из множества и возвращает его значение                                    |
| remove()                      | Удаляет элемент по значению                                                               |
| symmetric_difference()        | Возвращает множество, содержащее симметричные разности двух множеств                      |
| symmetric_difference_update() | Вставляет симметричные разности из этого множества и другого                              |
| union()                       | Возвращает множество, содержащее объединение множеств                                     |
| update()                      | Добавляет в множество элементы другого множества                                          |

# Получение количества элементов множества
Функция `len()`

```python
>>> new_set = {'hello', 'there', 'here', 'are', 'numbers', 1, 2, 3, 19, 42}
>>> len(new_set)
# 10
```

# Добавление и удаление элементов

Множества являются изменяемыми объектами, поэтому элементы можно в них добавлять и удалять из них. Для добавления 
элемента в множество используется метод `add()`

```python
>>> new_set.add(34)
# {1, 2, 3, 34, 42, 'there', 'are', 19, 'hello', 'here', 'numbers'}
```

Если попытаться методом `add()` добавить в множество повторяющийся элемент, то этот метод не вызовет исключения. Он
просто не добавит элемент.

В множество можно добавить сразу группу элементов при помощи метода `update()`. При вызове метода `update()` в качестве
аргумента передается объект, который содержит итерируемые элементы, такие как список, кортеж, строка или другое
множество. Отдельные элементы объекта, передаваемого в качестве аргумента, становятся элементами множества.

```python
>>> my_set = {1, 2, 3}
>>> my_set.update([4, 5, 6])
>>> my_set
# {1, 2, 3, 4, 5, 6}
```

Элемент из множества можно удалить либо методом `remove()`, либо методом `discard()`. Удаляемый элемент передается в 
качестве аргумента в один из этих методов, и этот элемент удаляется из множества. Единственная разница между этими 
двумя методами состоит в том, как они себя ведут, когда указанный элемент в множестве не найден. Метод `remove() `
вызывает исключение KeyError, а метод `discard()` исключение не вызывает. 

Чтобы удалить все элементы множества, используется метод `clear()`.

```python
>>> my_set = {1, 2, 3, 4, 5}
>>> my_set.remove(2)
>>> my_set
# {1, 3, 4, 5}

>>> my_set.discard(5)
# {1, 2, 3, 4}

>>> my_set.discard(100)

>>> my_set.remove(100)
# Traceback (most recent call last):
#   ...
# KeyError: 100

>>> my_set.clear()
# set()
```

Чтобы проверить вхождение элемента в множество, используется оператор `in` или `not in`.

```python
>>> my_set = {1, 2, 3, 4, 5}
>>> 5 in my_set
# True

>>> 100 in my_set
# False

>>> 3 not in my_set
# False
```

# Объединение множеств

Объединение двух множеств — это операция, в результате которой получается множество, содержащее все элементы обоих 
множеств. В Python для получения объединения двух множеств вызывается метод `union()`. Вот общий формат вызова:

`множество1.union(множество2)`

В данном формате множество1 и множество2 — это множества. Данный метод возвращает множество, в которое входят 
элементы множества1 и элементы множества2. 

Для объединения двух множеств можно также использовать оператор |. Вот общий формат
выражения с использованием оператора | с двумя множествами:

`множество1 | множество2`

Здесь множество1 и множество2 — это множества. Данное выражение возвращает множество, в которое входят элементы 
множества1 и элементы множества2.

```python
>>> set1 = {1, 2, 3, 4, 5}
>>> set2 = {3, 4, 5, 6, 7}

>>> set1.union(set2)
# {1, 2, 3, 4, 5, 6, 7}

>>> set1 | set2
# {1, 2, 3, 4, 5, 6, 7}
```

# Пересечение множеств

Пересечение двух множеств — это операция над множествами, при которой в итоговое множество входят только те элементы, 
которые находятся в обоих множествах. В Python для получения пересечения двух множеств вызывается метод 
`intersection()`. Вот общий формат вызова:

`множество1.intersection(множество2)`

Здесь множество1 и множество2 — это множества. Данный метод возвращает множество, в которое входят элементы, 
находящиеся одновременно в множестве1 и в множестве2.

Для нахождения пересечения двух множеств можно также использовать оператор `&`. Вот общий формат выражения с 
использованием оператора & с двумя множествами:

`множество1 & множество2`
Здесь множество1 и множество2 — это множества. Данное выражение возвращает множество, в которое входят элементы, 
находящиеся одновременно в множестве1 и в множестве2. 

```python
>>> set1 = {1, 2, 3, 4, 5}
>>> set2 = {3, 4, 5, 6, 7}

>>> set1.intersection(set2)
# {3, 4, 5}

>>> set1 & set2
# {3, 4, 5}
```

# Разность множеств
Разность множества1 и множества2 — это все элементы множества1, не входящие в множество2. В Python для получения 
разности двух множеств вызывается метод `difference()` Вот общий формат вызова:

`множество1.difference(множество2)`

Здесь множество1 и множество2 — это множества. Данный метод возвращает множество, в которое входят все элементы 
множества1, не входящие в множество2. 

Для нахождения разности двух множеств можно также использовать оператор `-`. Вот общий формат выражения с 
использованием оператора - с двумя множествами:

`множество1 - множество2`

Здесь множество1 и множество2 — это множества. Данное выражение возвращает множество, в которое входят все элементы 
множества1, не входящие в множество2. 

```python
>>> set1 = set([1, 2, 3, 4])
>>> set2 = set([3, 4, 5, 6])

>>> set1.difference(set2)
# {1, 2}

>>> set1 - set2
# {1, 2}
```

# Симметрическая разность множеств

Симметричная разность двух множеств — это множество, которое содержит элементы, не принадлежащие одновременно 
обоим исходным множествам. Иными словами, это элементы, которые входят в одно из множеств, но не входят в оба 
множества одновременно. В Python для получения симметричной разности двух множеств вызывается метод 
`symmetric_difference()`.Вот общий формат вызова:

`множество1.symmetric_difference(множество2)`

Здесь множество1 и множество2 — это множества. Данный метод возвращает множество, в которое входят элементы либо 
множества1, либо множества2, но не входят в оба множества одновременно. 

Для нахождения симметричной разности двух множеств можно также использовать оператор `^`. Вот общий формат выражения с 
использованием оператора `^` с двумя множествами:

`множество1 ^ множество2`

В данном формате множество1 и множество2 — это множества. Это выражение возвращает множество, в которое входят 
элементы либо множества1, либо множества2, но не входят в оба множества одновременно. 

```python
>>> set1 = {1, 2, 3, 4, 5}
>>> set2 = {4, 5, 6, 7}

>>> set1.symmetric_difference(set2)
# c

>>> set1 ^ set2
# set1 ^ set2
```

# Подмножества и надмножества

Предположим, что имеется два множества, и одно из этих множеств содержит все элементы другого множества. Вот пример:

```python
>>> setl = set([1, 2, 3, 4]) 
>>> set2 = set([2, 3])

>>> set2.issubset(set2)
# True

>>> set1.issuperset(set2)
# True
```

В этом примере set1 содержит все элементы set2. Эго означает, что set2 является подмножеством setl. Это также означает,
что set1 является надмножеством set2. В Python для определения, является ли одно из множеств подмножеством другого, 
вызывается метод `issubset()`. Вот общий формат вызова: 

`множество2.issubset(множество1)`

Здесь множество1 и множество2 — это множества. Данный метод возвращает True, если множество2 является подмножеством 
множества1. В противном случае он возвращает False.  Для того чтобы определить, является ли одно из множеств 
надмножеством другого, вызывается метод `issuperset()`. Вот общий формат вызова:

`множество1.issuperset(множество2)`


## Set Comprehension

Set comprehension в Python — это компактный способ создавать множества (set), используя выражения, которые 
позволяют генерировать и модифицировать элементы на лету. Этот метод похож на list comprehension, но вместо списков 
создает множества, гарантируя уникальность элементов. Синтаксис set comprehension включает в себя выражение и один или 
несколько циклов for и условий if.

Синтаксис set comprehension выглядит следующим образом:

`{выражение for переменная in итерируемый_объект if условие}`

выражение — это значение, которое будет добавлено в итоговое множество;
переменная — переменная, которая принимает значение каждого элемента из итерируемого объекта;
итерируемый_объект — коллекция или генератор, по которому происходит итерация;
условие — необязательный фильтр, который применяется к каждому элементу.

```python
>>> numbers = [1, 2, 3, 4, 5, 2, 3, 4]
>>> squared_even_numbers = {x**2 for x in numbers if not x % 2}
 # {16, 4}
```

### frozenset

**frozenset** — это неизменяемый вариант множества (set). Так же, как и обычные множества, frozenset позволяет хранить 
только уникальные элементы, но, в отличие от них, не поддерживает операции, модифицирующие множество (такие как 
добавление или удаление элементов) после его создания. Это делает frozenset идеальным для использования в качестве 
ключей словаря или элементов другого множества, где требуется неизменяемость.

**Особенности frozenset**
- Неизменяемость: После создания frozenset нельзя изменить. Это означает, что у него нет методов, таких как add или remove, которые есть у обычного множества.
- Хешируемость: Благодаря своей неизменяемости, frozenset может быть использован в качестве ключа в словаре (dict) или как элемент другого множества.
- Поддержка операций над множествами: frozenset поддерживает все операции, доступные для обычных множеств, такие как объединение, пересечение, разность и симметрическая разность.

```python
>>> fs1 = frozenset([1, 2, 3])
>>> fs2 = frozenset([4, 5, 6])

>>> my_dict = {fs1: "abc", fs2: "def"}

>>> my_dict[fs1]
# abc

>>> my_dict[fs2]
# def

>>> fs1 = frozenset([1, 2, 3, 4, 5])
>>> fs2 = frozenset([4, 5, 6, 7, 8])

>>> union = fs1 | fs2
# frozenset({1, 2, 3, 4, 5, 6, 7, 8})

>>> intersection = fs1 & fs2
# frozenset({4, 5})

>>> difference = fs1 - fs2
# frozenset({1, 2, 3})

>>> symmetric_difference = fs1 ^ fs2
# frozenset({1, 2, 3, 6, 7, 8})
```
