## Функции (продолжение)

## Функции высшего порядка

Функции высшего порядка

В программировании (и в математике) функциями высшего порядка называются функции, которые выполняют одно (или оба) из
этих действий:

1. Принимают одну (и более) функций в качестве аргументов.
2. Возвращают функцию в качестве результата.

Все остальные функции считаются функциями первого порядка.

## map (function, iterable)

Функция map() — еще одна полезная встроенная функция, обрабатывающая итерабельные объекты. Подобно функции filter(),
map() также принимает еще одну функцию, с помощью которой перебираются все элементы по очереди. Как и остальные пять
рассмотренных нами функций, функция map() возвращает специальный объект map, в дальнейшем преобразовываемый в список или
кортеж. Вот несколько примеров, показывающих, как применить функцию map() на практике:

```python
def times_10(num):
    return num * 10


nums = [1, 2, 3, 4, 5]

nums = list(map(times_10, nums))
print(nums)

# [10, 20, 30, 40, 50]

```

Как и ранее, вместо функции можно написать лямбда-выражение.

```python
times_10 = lambda num: num * 10

```

Рассмотрите внимательно пример перебора функцией map нескольких итерируемых объектов:

```python
def add(n1, n2, n3):
    return n1 + n2 + n3


nums1 = [1, 3, 5, 7, 9]
nums2 = [2, 4, 6, 8, 10]
nums3 = [11, 12, 13, 14, 15]

sums = list(map(add, nums1, nums2, nums3))
print(sums)

# [14, 19, 24, 29, 34]
```

В примере функция map() возвращает список с суммами чисел из разных коллекций по общим индексам.

## filter (function, iterable)

Функция filter() применяется для простой фильтрации итерируемого объекта без необходимости создания собственного цикла
или дополнительных переменных. Все, что вам потребуется, — это функция filter(), возвращающая либо True, либо False, в
зависимости от условия. Если функция возвращает False, то элемент будет удален из итерируемого объекта, если True —
останется. Как и другие функции, рассмотренные нами до сих пор, функция filter() также возвращает специальный объект
filter, который затем преобразовывается в список или кортеж. Пример поможет понять, как применяется фильтрация:

```python
people = [
    ('Johnny', 22),
    ('Adam', 18),
    ('Mark', 12),
    ('Jack', 14),
    ('Sam', 20)
]


def is_adult(person):  # person --> (name, age)
    return person[1] >= 18


adults = filter(is_adult, people)
print(list(adults))

# [('Johnny', 22), ('Adam', 18), ('Sam', 20)]

```

При желании напишите лямбда-выражение вместо функции, выступающей в качестве условия для фильтрации итерируемого
объекта.

```python
people = [
    ('Johnny', 22),
    ('Adam', 18),
    ('Mark', 12),
    ('Jack', 14),
    ('Sam', 20)
]

is_adult = lambda person: person[1] >= 18

adults = filter(is_adult, people)
print(list(adults))
# [('Johnny', 22), ('Adam', 18), ('Sam', 20)]
```

## zip (iterable1, iterable2, iterable3, …)

Функция zip() принимает любое количество итерируемых объектов. Итерируемый объект — это любая коллекция,
такая как список, кортеж, множество, словарь или range. Снова обратите внимание, что при обработке словаря функция
просматривает только ключ, но не значения.

Функция zip() попарно объединяет элементы переданных коллекций по их индексу и возвращает специальный объект zip,
который можно преобразовать в список или кортеж, состоящий из кортежей. Функция zip() обычно применяется для
одновременного перебора нескольких списков.

```python
names = ["Johnny", "Adam", "Mark"]
ages = [14, 16, 17]
people = list(zip(names, ages))
print(people)
# [('Johnny', 14), ('Adam', 16), ('Mark', 17)]
```

Объект zip можно обойти в цикле следующим образом:

```python
names = ["Johnny", "Adam", "Mark"]
ages = [14, 16, 17]

for name, age in zip(names, ages):
    print(name, age)
```

## enumerate (iterable, start=0)

Функция enumerate() чаще всего применяется для циклического просмотра списка. После передачи итерируемого объекта в
качестве параметра функция возвращает список из кортежей, где каждый кортеж содержит индекс элемента и сам элемент.
Функция возвращает специальный объект enumerate, поэтому впоследствии вам придется все так же преобразовать его в список
или кортеж.

```python
names = ["Johnny", "Adam", "Mark"]
enum_names = list(enumerate(names))
print(enum_names)
# [(0, 'Johnny'), (1, 'Adam'), (2, 'Mark')]
```

Параметр start указывает функции enumerate(), с какого числа начинать отсчет индексов.

```python
names = ["Johnny", "Adam", "Mark"]
enum_names = list(enumerate(names, start=2))
print(enum_names)

# [(2, 'Johnny'), (3, 'Adam'), (4, 'Mark')]
```

Объект enumerate можно обойти в цикле следующим образом:

```python
names = ["Johnny", "Adam", "Mark"]
for i, name in enumerate(names):
    print(i, name)
```

## reduce(func, iterable[, initial])

В Python функция reduce() не является встроенной, а расположена в модуле functools. Выглядит она сложнее предыдущих
двух, поэтому давайте разбираться. Она принимает итерируемый объект, а возвращает одиночный результат. Взглянем на
синтаксис.

Параметр func – функция, к которой кумулятивно применяется каждый элемент iterable. Значение initial является
необязательным и в случае указания, служит стартовым значением или значением по умолчанию, если итерируемый объект пуст.

Функция func требует два аргумента (или один, если указан initial). Разберем на примере. Напишем программу, которая
считает сумму чисел в списке.

Пример
```python
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6]
result = reduce(lambda x, y : x + y, numbers)
print(result) 
# 21

```
Не забываем подключить модуль functools и импортировать из нее reduce(). Думаю, очевидно, что произойдет, если в
параметр initial передать число 10.

Пример
```python
from functools import reduce

numbers = [1, 2, 3, 4, 5, 6]
result = reduce(lambda x, y : x + y, numbers, 10)
print(result) 
# 31
```

## Замыкания и вложенные функции

Замыкания и вложенные функции

В программировании существует концепция, называемая _замыканием_ (closure), когда вложенная функция имеет доступ к
локальным переменным функции более высокого порядка, после того, как внешняя функция уже завершила свою работу:

```python
def print_greetings(text):
    def say_hello():
        print(text)

    return say_hello


print_hi = print_greetings('Привет, как дела?!')
print_hi()
```

Сохранение доступа к переменным функции более высокого порядка возможно благодаря своеобразному виртуальному
контейнеру – стеку. В приведенном ниже примере при вызове `outer_function()` в стеке сохраняется фрейм, в котором
находятся вложенная функция `inner_function()` (как константа) и строка `text_1` (как локальная переменная). Поскольку
функция `inner_function()` ссылается на переменную `text_1`, значение переменной остается доступным после того, как
функция высшего порядка уже завершила свою работу.

```python
def outer_function(text_1):
    def inner_function():
        text_2 = 'Это функция первого порядка - внутренняя'
        print(text_2)
        print(f'{text_1}, ee значение было сохранено во фрейме')

    return inner_function


my_function = outer_function('Это функция высшего порядка - внешняя')
my_function()

# Output:
# Это функция первого порядка - внутренняя
# Это функция высшего порядка - внешняя, ee значение было сохранено во фрейме
```

На практике замыкания используются для инкапсуляции кода и скрытия важных данных. С помощью замыканий также можно
избежать использования глобальных переменных.

Важно заметить, что не всякая вложенная функция автоматически выступает в качестве замыкания, то есть сохраняет значения
всех переменных из доступной области видимости: если во вложенной функции нет ссылок на какие-то переменные из функции
высшего порядка, они не будут сохранены, и в этом случае вложенная функция считается просто вложенной функцией, а не
замыканием. В приведенном ниже примере интерпретатор Python демонстрирует, что именно он посчитал замыканием, а что –
нет:

```python
def higher_order():
    text1 = 'Привет'
    text2 = 'Учишь Python?'

    def nested():
        return text1

    return nested


my_function = higher_order()
my_function
# <function higher_order.<locals>.nested at 0x025B4390>
my_function.__closure__
# (<cell at 0x02578B30: str object at 0x025B17A0>,)
my_function.__closure__[0].cell_contents
# 'Привет'
higher_order.__closure__ is None
```

Значение переменной `text2` не было сохранено в `__closure__`, в отличие от использованного во вложенной функции
`nested()` значения `text1` – если выполнить команду `my_function.__closure__[1].cell_contents`, получим ошибку, так
как никаких других значений в кортеже нет:

```
Traceback (most recent call last):
File "<pyshell>", line 1, in <module>
IndexError: tuple index out of range
```

В этом можно также убедиться, выполнив команду по выводу имен переменных, ставших замыканиями:

```python
higher_order.__code__.co_cellvars
# ('text1',)
```

## Рекурсивные функции

_Рекурсивная функция_ – это функция, которая вызывает сама себя, и при каждом очередном вызове использует данные,
созданные во время предыдущего вызова. В программировании есть ряд задач, которые проще (но не всегда эффективнее)
решаются с помощью рекурсии. Чтобы разобраться в принципе работы рекурсивных функций, нужно понять (в самых общих
чертах) концепцию стека вызовов.

_Стек_ – это структура данных LIFO (last in, first out): информация последовательно добавляется в «стопку» , каждый
новый объект помещается поверх предыдущего, а извлекаются объекты в обратном порядке, – начиная с верхнего. Работу стека
отлично иллюстрирует добавление данных в список с помощью `append()` и извлечение информации посредством `pop()`:

```python
stack = []
for i in range(1, 11):
    stack.append(f'{i}-й элемент')
    print(f'+ {i}-й элемент добавлен')
    for i in stack:
        print(i, end=" ")
print('\n')
for i in range(len(stack)):
    print('В стеке: ', end=" ")
    for i in stack:
        print(i, end=" ")
    print(f'\n{stack.pop()} удален из стека')

# Output:
# + 1-й элемент добавлен
# 1-й элемент + 2-й элемент добавлен
# 1-й элемент 2-й элемент + 3-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент + 4-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент + 5-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент + 6-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент + 7-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент + 8-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент + 9-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент + 10-й элемент добавлен
# 1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент 10-й элемент 
# 
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент 10-й элемент 
# 10-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 9-й элемент 
# 9-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 8-й элемент 
# 8-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 7-й элемент 
# 7-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 6-й элемент 
# 6-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 5-й элемент 
# 5-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 4-й элемент 
# 4-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 3-й элемент 
# 3-й элемент удален из стека
# В стеке:  1-й элемент 2-й элемент 
# 2-й элемент удален из стека
# В стеке:  1-й элемент 
# 1-й элемент удален из стека
```

Стек вызовов, в свою очередь, – это область памяти, в которой выполняются функции. При каждом вызове функции создается
фрейм – фрагмент памяти, – в котором содержится:

- информация о текущем состоянии выполнения функции;
- значения всех переменных, которые функция получила для обработки;
- локальные данные, созданные во время очередного вызова;
- сведения о строке программы, к которой нужно вернуться после выполнения функции.

Фреймы помещаются в стек вызовов, как уже было показано в примере выше, и удаляются точно так же, сверху вниз.
Рекурсивные функции при каждом новом вызове используют данные, созданные во время работы предыдущего вызова.

Программисту не нужно беспокоиться о работе стека вызовов – созданием фреймов и управлением стеком занимается
интерпретатор. Однако понимание принципа работы стека вызовов значительно упрощает создание рекурсивных функций.
Неверное же использование рекурсии приводит к переполнению стека (stack overflow). Популярный сайт StackOverflow назван
как раз в честь этой ошибки.

Переполнить стек в опытных целях можно с помощью простейшей рекурсивной функции, которая бесконечно вызывает сама себя,
но не возвращает никаких данных и не содержит никакого условия для прекращения своей работы.

Чтобы стек вызовов не переполнялся, в каждой рекурсивной функции всегда должны быть предусмотрены два случая:

- **Граничный**, при котором функция завершает работу и возвращает данные в основную программу.
- **Рекурсивный**, при котором функция продолжает вызывать себя.

Вот пример простейшей рекурсивной функции, в которой учтены оба случая:

```python
def greetings(st):
    print(st)
    if len(st) == 0:  # Граничный случай
        return
    else:  # Рекурсивный случай
        greetings(st[:-1])


greetings('Hello, world!')

# Output:
# Hello, world!
# Hello, world
# Hello, worl
# Hello, wor
# Hello, wo
# Hello, w
# Hello, 
# Hello,
# Hello
# Hell
# Hel
# He
# H
```

# Скорость выполнения: итерация vs рекурсия

Рекурсивные функции работают медленнее обычных, поэтому их стоит применять только тогда, когда решить задачу без
рекурсии сложно.

Цикл выполняет итерацию (перебор), причем справляется с задачей гораздо быстрее, чем рекурсивная функция, поскольку
рекурсия совершает множество повторных вызовов, и с увеличением числа элементов последовательности количество повторов
растет лавинообразно.

Итерацию можно назвать противоположностью рекурсии. Всегда, когда задачу можно решить итерацией (либо итерацией с
использованием стека), следует делать выбор в пользу цикла for или while вместо рекурсии.

# Классический пример

Вычисление факториала числа.

Примечание для рекурсивного решения: предположим, нам нужно вычислить 5! Факториал 5 равен: 5 х 4 х 3 х 2 х 1. Факториал
4: 4 х 3 х 2 х 1, факториал 3: 3 х 2 х 1, факториал 2: 2 х 1, и факториал 1 равен 1. Очевидно, что 5! = 5 x 4!, 4! = 4 x
3!, 3! = 3 x 2! и так далее до граничного случая 1! = 1, то есть каждый последующий факториал включает в себя
определение предыдущего.

```python
# iteration
def fact_iter(n):
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return factorial


print(fact_iter(int(input())))


# recursion
def fact_recursive(n):
    if n == 1:  # граничный случай
        return 1
    else:  # рекурсивный случай
        return n * fact_recursive(n - 1)


print(fact_recursive(int(input())))

# Input:
# 12
# Output:
# 479001600
```

# Подведем итоги

Рекурсию стоит применять для решения задач, в которых:

- Используется древовидная структура данных.
- Нужно предусмотреть возврат к предыдущей отправной точке (например, при поиске выхода из лабиринта).
- Глубина рекурсивных вызовов находится в пределах разумного и не приведет к переполнению стека.

**Во всех остальных случаях целесообразнее использовать итерацию либо итерацию и стек.**
