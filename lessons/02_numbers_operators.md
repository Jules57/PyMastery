### Булевая алгебра и условия

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ce/George_Boole_color.jpg/274px-George_Boole_color.jpg)

## Что такое булева алгебра?

Булева алгебра - это раздел математики, который занимается операциями над логическими значениями и включает двоичные
переменные. Булева алгебра ведет свое начало от книги математика Джорджа Буля (Картинка выше) 1854 года.

Основные понятия в Булевой алгебре это **true** и **false**, они же **истина** и **ложь**, и три оператора **not**,
**and**, и **or**. Они же **не**, **и** и **или**.

Очень большая часть программирования строится именно на двоичной алгебре, и оперирует понятиями из этой алгебры.

Тип **Python boolean** является одним из встроенных типов данных Python. Он используется для представления истинности
значения выражения. Например, выражение `1 < 2` является `True`, тогда как выражение `0 == 1` является `False`.
Понимание того, как ведут себя логические значения Python, является важным для качественного программирования на Python.

Запомните слова **True** и **False** именно с большой буквы являются ключевыми в языке python, и вы не можете
использовать их в качестве названия переменной, функции, класса и тому подобное.

![](https://i.imgflip.com/55t2ce.jpg)

Такой тип данных называется **булевый**, а такие переменные - **булевые**

### В чем суть булевого типа данных?

Может иметь только два значения *True* и *False*

![](https://static.vecteezy.com/system/resources/previews/004/581/253/original/check-and-cross-icon-right-and-wrong-icon-yes-or-no-buttons-true-or-false-good-or-bad-selection-design-design-free-vector.jpg)

Существует три вариант присвоения переменной булевого значения:

1) Явно создать переменную такого типа

```python
some_true_variable = True
some_false_variable = False
```

2) Приведение типов

Python - это язык с динамической и строгой типизацией, поэтому мы не должны обозначать, какую именно переменную мы
создаем, но мы не можем сложить или сравнить между собой число и строку.

А что если нам нужно сложить число со строкой? Например мы имеем переменную со значением 45 и другую со значением '47'.
Первая это число, вторая это строка. В таком случае мы имеем два варианта. Первый сложить переменные как числа, второй
сложить их как строки. Чтобы мы имели такую возможность мы должны изменить ты одного из них, и дальше работать с одним
и тем же типом данных. Чтобы привести один тип к другому, нужно написать название типа маленькими буквами и в скобках
указать, что именно мы хотим изменить.

```python
my_num = 45  # число
my_str = '47'  # строка
print(my_num + my_str)  # вызовет ошибку
print(my_num + int(my_str))  # выведет 92
print(str(my_num) + my_str)  # выведет '4547'

my_str_not_number = 'blabla'
int(my_str_not_number)  # вызовет ошибку, так как эта строка не может быть преобразована в число
```

Мы можем преобразовать любой тип данных в **bool(anything)**

Для каждого типа данных свои правила приведения к логическому типу.

Непустые строки преобразуются в **True**

```python
bool('')  # False
bool('asdasd')  # True
empty_string = ''
not_empty_string = 'some text'
bool(empty_string)  # False
bool(not_empty_string)  # True
```

Любое числовое значение отличное от **0** - это `True`

```python
bool(4)  # True
bool(0)  # False
bool(-3)  # True
positive = 5
negative = -4
zero = 0
bool(positive)  # True
bool(zero)  # False
bool(negative)  # True
bool(positive - 5)  # False
bool(0.0)  # False
```

3) Как результат математического сравнения или результат выполнения операторов.

#### Математические сравнения

Для сравнения в Python используются математические операторы: `<` (строго меньше), `<=` (меньше или равно), `==` (
равно),
`>` (строго больше), `>=` (больше или равно).

Сравнивать можно числа, строки и другие типы данных.

**>** - больше

```python
result = 5 > 3  # True
another_result = 3 > 5  # False
compare_the_same_values = 3 > 3  # False
small_value = 4
big_value = 6
compare_variables = big_value > small_value  # True
compare_variables = small_value > big_value  # буде False
compare_strings = 'ab' > 'baa'  # False
```

**<** - меньше

```python
result = 5 < 3  # False
another_result = 3 < 5  # True
compare_the_same_values = 3 < 3  # False
small_value = 4
big_value = 6
compare_variables = big_value < small_value  # False
compare_variables = small_value < big_value  # True
compare_strings = 'ab' < 'baa'  # True
```

**>=** - больше или равно

```python
result = 5 >= 3  # значення змінної буде True
another_result = 3 >= 5  # значення змінної буде False
compare_the_same_values = 3 >= 3  # значення змінної буде True
small_value = 4
big_value = 6
compare_variables = big_value >= small_value  # значення змінної буде True
compare_variables = small_value >= big_value  # значення змінної буде False
compare_strings = 'ab' >= 'baa'  # значення змінної буде False
```

**<=** - меньше чи дорівнює

```python
result = 5 <= 3  # значення змінної буде True
another_result = 3 <= 5  # значення змінної буде False
compare_the_same_values = 3 <= 3  # значення змінної буде True
small_value = 4
big_value = 6
compare_variables = big_value <= small_value  # значення змінної буде False
compare_variables = small_value <= big_value  # значення змінної буде True
compare_strings = 'ab' <= 'baa'  # значення змінної буде True
```

**==** - дорівнює

```python
result = 5 == 3  # значення змінної буде False
another_result = 3 == 5  # значення змінної буде False
compare_the_same_values = 3 == 3  # значення змінної буде True
small_value = 4
big_value = 6
compare_variables = big_value == small_value  # значення змінної буде False
compare_variables = small_value == big_value  # значення змінної буде False
compare_strings = 'ab' == 'baa'  # значення змінної буде False
```

#### Логические операторы в Python

**and** - логическое **И**, **возвращает значение**

Как работает? Если **все** значения в выражении являются истиной, то результат тоже будет истиной. Обратите внимание,
что `and` возвращает первое значение, которое при приведении к булевому типу приобретает значение False, или
последнее значение, если все значения при приведении возвращают True.

```python
True and True  # True
False and True  # False
False and False  # False
True and False  # False
True and ''  # ''
'a' and 0  # 0
0 and ''  # 0
10 and ''  # ''
'bla' and 23  # 23
```

**or** - логическое **ИЛИ**, **возвращает значение**

Если одно значение в выражении при приведении дает True, то и результат будет True.

```python
True or True  # True
False or True  # True
False or False  # False
True or False  # True
True or ''  # True
'a' or 0  # 'a'
0 or ''  # ''
10 or ''  # 10
'bla' or 23  # 'bla'
```

**not** - превращает True в False и наоборот, то есть инвертирует значение. Оператор `not` сначала приводит значение
к булевому типу, а потом меняет его на противоположное.

```python
not True  # False
not False  # True
not ''  # True
not 33  # False
```

**in** - проверка вхождения подколлекции в коллекцию.

```python
'ab' in 'bcde'  # False
'ab' in 'abcd'  # True
```

**is** - **используется только с переменными**. Проверяет идентичность объектов, на которые ссылаются переменные.

```python
a = 500
b = 500
a is b  # False
c = 500
d = c
c is d  # True
```

В Python есть интересная особенность, связанная с работой оператора is. Разработчики Python приняли решение, что числа
в диапазоне от -5 до 256 используются настолько часто, что не имеет смысла каждый раз создавать для них новые объекты
в памяти. Это привело к тому, что при запуске скрипта числа в указанном диапазоне загружаются во внутренний пул
целочисленных объектов (integer pool), который управляется интерпретатором Python.

Эта оптимизация позволяет повысить эффективность использования памяти и ускорить процесс выполнения кода, поскольку
уменьшается количество необходимых выделений и освобождений памяти. Когда в коде Python создается переменная, которой
присваивается значение в этом диапазоне, интерпретатор не создает новый объект, а вместо этого ссылается на уже
существующий объект в пуле. Это означает, что все переменные с одинаковыми значениями в диапазоне от -5 до 256 (оба
значения включительно) фактически ссылаются на один и тот же объект в памяти.

Интересно, что это поведение специфично для CPython – стандартной реализации Python, и может отличаться в других
реализациях, таких как PyPy или Jython.

Эта особенность языка может вызывать неочевидные эффекты, особенно при использовании оператора `is`, который проверяет,
ссылаются ли две переменные на один и тот же объект в памяти. Например:

```python
a = 200
b = 200
a is b  # True
a = 300
b = 300
a is b  # False
```

### Приоритет операторов

Приоритет операторов сравнения в Python является ключевым моментом для понимания логики выполнения выражений. Операторы
сравнения определяют отношения между значениями и включают стандартные математические сравнения. Понимание
приоритета этих операторов помогает избежать ошибок в логике программы и понять, как интерпретируется сложное выражение.

Приоритеты операторов сравнения в Python:

1. Операторы равенства и неравенства (==, !=):

- Эти операторы сравнивают значения на равенство или неравенство.
- Они имеют одинаковый приоритет и являются одними из самых низких по приоритету среди всех операторов.

2. Операторы отношений (<, <=, >, >=):

- Они используются для сравнения чисел и других упорядоченных типов данных.
- Эти операторы имеют выше приоритет, чем операторы равенства и неравенства.

3. Логические операторы (and, or, not):

- not имеет самый высокий приоритет среди логических операторов.
- and имеет более высокий приоритет, чем or.
- Оба оператора and и or имеют более низкий приоритет, чем операторы сравнения.


  **Важные моменты:**
- Читаемость кода: Чтобы улучшить читаемость, рекомендуется использовать скобки для явного указания порядка
  выполнения операций, особенно в сложных выражениях.
- Каскадные сравнения: Python позволяет каскадное сравнение, например, a < b <= c, которое эквивалентно (a < b) and
  (b <= c). Это уникальная особенность Python и помогает избежать излишнего написания кода.

## Cравнение последовательностей

Объекты последовательностей обычно можно сравнивать с другими объектами, имеющими тот же тип последовательности. При 
сравнении используется лексикографическое упорядочивание: сначала сравниваются первые два элемента, и если они 
отличаются, то это определяет результат сравнения; если они равны, то сравниваются следующие два элемента, и так далее,
пока ни одна из последовательностей не будет исчерпана. Если два сравниваемых элемента сами являются 
последовательностями одного типа, то лексикографическое сравнение выполняется рекурсивно. Если все элементы двух 
последовательностей сравниваются одинаково, то последовательности считаются равными. Если одна из последовательностей 
является начальной подпоследовательностью другой, то более короткая последовательность считается меньшей (меньшей). 

Лексикографическое упорядочивание строк использует номер кодовой точки Unicode для упорядочивания отдельных символов. 
Некоторые примеры сравнений между последовательностями одного типа:

```python
(1, 2, 3) < (1, 2, 4)
[1, 2, 3] < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4) < (1, 2, 4)
(1, 2) < (1, 2, -1)
(1, 2, 3) == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)
```

Подведем итоги приоритетности операторов:

1. `()` - операции в скобках
2. `**` - возведение в степень
3. `+х`, `-х` - унарные операторы + и - (применяются к одному операнду)
4. `*`, `/`, `//`, `%` - математические операторы умножения и деления
5. `+`, `-` - математические операторы сложения и вычитания
6. `>>`, `<<` - битовый сдвиг
7. `&` - битовое И
8. `^` - битовое исключающее ИЛИ
9. `|` - битовое ИЛИ
6. `<`,  `<=`,  `==`, `=>`, `>` - операторы сравнения имеют одинаковый приоритет и выполняются последовательно
7. `not` - логическое НЕ
8. `and` - логическое И
9. `or` - логическое ИЛИ


Хороший план - использовать скобки)

Примеры

```python
age = int(input('Please enter your age: '))
name = input('Please enter your name: ')

age > 18 and 'v' not in name.lower()
age < 10 or name == 'Kate'
age // 3 == 1 and len(name) > 4 or str(age) in name
```

## if, elif, else або навіщо це все треба

В програмуванні є декілька дуже базових концепцій, одна з них це розгалуження

Дуже просто, виконувати блок коду лише якщо умова є істиною.

В пайтоні для позначення блоків коду ми використовуємо звичайні відступи. В багатьох мовах програмування використовують
для цього різні дужки. У нас використовується 4 пробіли (на більшості компʼютерів кнопка tab працює саме як 4 пробіла)

### if

Зараз мі розглянемо ключові слова **if**, **elif**, **else**, але в пайтоні будь які структури які ви будете вивчати
далі використовують такий самий синтаксіс з чотирьма пробілами (або 1 табом)

```python
a = 100
b = 'bla'
if a:
    print('will be printed')
if a > 50:
    print('will be printed')
if 'c' in b:
    print('wont be printed')
```

Коли нам потрібно добавити умову, ми просто пишемо ключове слово **if** після нього ми вказуемо умову та ставимо
двокрапку. Все що мае виконуватися за умови має бути описане нижче зі зміщенням у 4 пробіли. Все що буде написано знову
на попередньому рівні буде виконане без умов.

### else

Якщо нам потрібно розбити виконання коду на те що робити коли умова виконується і коли ні ми можемо використати ключове
слово **else**

```python
a = 100
if a > 200:
    print('wont be printed')
else:
    print('will be printed')
```

### elif

також ми можемо додати проміжних умов якщо не виконався перший іф за допомогую **elif** який також потребує умови:

```python
a = 80
if a > 100:
    print('wontbe printed')
elif a > 50:
    print('will be printed')
else:
    print('wont be printed')
```

Насправді це просто синтаксічне спрощення такої конструкції



## match case


ChatGPT
В Python 3.10 была введена новая конструкция match case, также известная как "структурное сопоставление с образцом" 
(structural pattern matching). Это мощное средство для сравнения значений с определенными "шаблонами" и выполнения 
соответствующих действий в зависимости от успешности сопоставления.

Основы match case
match case можно рассматривать как расширенный аналог оператора switch в других языках программирования, но с более 
широкими возможностями. Основная идея заключается в том, что match берет выражение и сравнивает его с 
последовательностью шаблонов, определенных в case. При нахождении соответствия выполняется блок кода, ассоциированный 
с этим шаблоном.

Идея в том, что мы можем задать несколько вариантов проверки переменной и выполнить только те условия, в которых
результат проверки будет True.

Концепция:

```python
match <выражение>:
    case <шаблон1>:
        <действие1>
    case <шаблон2>:
        <действие2>
    ...
    case _:
        <действие по умолчанию>
```
- `<выражение>: Выражение, значение которого будет сопоставляться с шаблонами.
- <шаблон>: Шаблон, с которым сравнивается значение. Может быть простым (например, литералом или переменной) или 
сложным (например, структурой данных).
- <действие>: Код, который выполняется, если соответствие найдено.
- _: _Wildcard_ шаблон, соответствующий любому значению, если другие шаблоны не подошли (аналог "default" в switch).

Пример:

```python
status = 400
match status:
    case 400:
        print("Bad request")
    case 401:
        print("Unauthorized")
    case 403:
        print("Forbidden")
    case 404:
        print("Not found")
```



Практика/Домашне завдання:

1. Користувач задає змінну вік. Якщо він старше ніж 18 роздрукуйте що все добре, якщо ні, то роздрукуйте що не все добре
2. Додати до першої умови, якщо вік більше ніж 100, роздрукувати текст що користувач вводить нас в оману
3. Додати прінти чи є введений вік парним, чи непарним.
4. Додати що користувач вводить ще й ім'я. І якщо в імені є літера 'a', то написати що ми навідь не збираємося його
   перевіряти.
5. Перевірити якщо в імені є літера 'v' чи велика, чи маленька байдуже. І вік користувача парний, то написати що він
   виграв приз, якщо ні, то не виграв.

6. Спитати користувача вік, стать та ім'я. Для усіх молодше 15 ми пишемо що рекомендуємо теніс, для хлопців старше 15
   рекомендуємо футбол, для дівчат баскетбол, але якщо в імені є літера 'c' або 't', друкуємо що ми не рекомендуємо
   займатися спортом
