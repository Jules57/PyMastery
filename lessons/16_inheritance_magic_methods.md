# Урок 16. Множественное наследование. MRO. Magic methods.

![](https://i.ytimg.com/vi/ektST9ppziE/maxresdefault.jpg)

## Множественное наследование

![](https://python-course.eu/images/oop/clock_calendar_500w.webp)

Множественное наследование - это возможность у класса потомка наследовать функционал не от одного, а от нескольких
родителей. Благодаря этому мы можем создавать сложные структуры, сохраняя простой и легко-поддерживаемый код.

Во многих языках программирования нет множественного наследования, так что давайте разбираться, как это вообще работает.

Например, у нас есть класс автомобиля:

```python
class Auto:
    def ride(self):
        print("Riding on ground")

```

Также у нас есть класс для лодки:

```python
class Boat:
    def swim(self):
        print("Sailing in the ocean")

```

Теперь, если нам нужно запрограммировать автомобиль-амфибию, который будет плавать в воде и ездить по земле, мы вместо
написания нового класса можем просто унаследовать от уже существующих, просто написав их через запятую:

```python
class Auto:
    def ride(self):
        print("Riding on a ground")


class Boat:
    def swim(self):
        print("Sailing in the ocean")


class Amphibian(Auto, Boat):
    pass


a = Amphibian()
a.ride()
a.swim()
```

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSYboaqixXBn-OWESELK2fLejC9fvKLL4QvBA&usqp=CAU)

Теперь наш класс имеет атрибуты и методы обоих родителей (их может быть сколько угодно).

Обратите внимание, что объект класса Amphibian будет одновременно объектом класса Auto и Boat, то есть:

```python
a = Amphibian()
isinstance(a, Auto)
# True
isinstance(a, Boat)
# True
isinstance(a, Amphibian)
# True
```

### Миксины (Mixins)

Миксин, он же примесь, — это тип классов, которые нужны, чтобы добавлять к обычным классам какие-то методы или атрибуты,
но эти классы не используются для создания объектов, только как примесь. (Нас ничего не останавливает создать объект
этого класса, но задача в другом)

Представим, что мы программируем класс для автомобиля.
Мы хотим, чтобы у нас была возможность слушать музыку в машине.
Конечно, можно просто добавить метод `play_music()` в класс `Car`:

```python
class Car:
    def ride(self):
        print("Riding a car")

    def play_music(self, song):
        print(f"Now playing: {song}.")


c = Car()
c.ride()
# Riding a car
c.play_music("Queen - Bohemian Rhapsody")
# Now playing: Queen - Bohemian Rhapsody
```

Но что, если у нас есть еще и телефон, радио или любой другой девайс, с которого мы будем слушать музыку.
В таком случае лучше вынести функционал проигрывания музыки в отдельный класс-миксин:

```python
class MusicPlayerMixin:
    def play_music(self, song):
        print(f"Now playing: {song}.")
```

Мы можем "домешивать" этот класс в любой, где нужна функция проигрывания музыки:

```python
class Smartphone(MusicPlayerMixin):
    pass


class Radio(MusicPlayerMixin):
    pass


class Amphibian(Auto, Boat, MusicPlayerMixin):
    pass

```

### Diamond problem. MRO

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190612120714/diamond-problem-solution.png)

Итак, классы-наследники могут использовать родительские атрибуты и методы.
Но что, если у нескольких родителей будут одинаковые атрибуты или методы?
Какой метод в таком случае будет использовать наследник?

Рассмотрим классический пример:

```python
class A:
    def hi(self):
        print("A")


class B(A):
    def hi(self):
        print("B")


class C(A):
    def hi(self):
        print("C")


class D(B, C):
    pass


d = D()
d.hi()
```

Эта ситуация, так называемое ромбовидное наследование (diamond problem), решается в Python путем установления порядка
разрешения методов.

В Python3 для определения порядка используется алгоритм поиска в ширину, то есть сначала интерпретатор будет искать
метод `hi()` в классе B, если его там нет - в классе С, потом A.

В Python второй версии используется алгоритм поиска в глубину, то есть в данном случае - сначала B, потом - А, потом С.

В Pytho3 можно посмотреть в каком порядке будут проинспектированы родительские классы при помощи метода класса `mro()`:

### MRO - Method resolution order

Чтобы посмотреть, в каком порядке Python будет искать атрибуты или методы у родителей, у любого класса можно вызывать
метод `mro()`:

```python
>> D.mro()
[ <class '__main__.D'>, < class '__main__.B' >, < class '__main__.C' >, < class '__main__.A' >, < class 'object'>]
```

Обратите внимание, в конце всегда будет `object`, если вы используете любой Python версии 3.
Потому что вообще все отнаследовано от него, как я и говорил на прошлом занятии.

Если по какой-то причине вас не устраивает существующий порядок, есть возможность вызвать метод ровно из того класса,
откуда вам надо, но это считается плохой практикой и лучше так не делать, а полностью поменять структуру.

Если вам необходимо использовать метод конкретного родителя, например, `hi()` класса С, нужно напрямую вызвать его по 
имени класса, передав `self` в качестве аргумента:

```python
class D(B, C):
    def call_hi(self):
        C.hi(self)


d = D()
d.call_hi()
```

[Большая статья про МРО и вообще множественное наследование тут](https://habr.com/ru/post/62203/?_ga=2.205768979.1207595081.1598867257-330984554.1578271027)

## Magic methods (Они же иногда называются dunder-методы)

Что такое магические методы? Они всё в объектно-ориентированном Python. 
Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». 
Они всегда обрамлены двумя нижними подчеркиваниями, два вначале, два в конце (например, `__init__` или `__lt__`).

Это методы, которые отвечают за любые действия под "капотом". Те, которые выполняются неявно. Допустим, 
вам нужно сложить два объекта через оператор `+`, нам нужен магический метод `__add__`, или мы хотим поменять поведение 
при удалении `__del__`, поведение при переборе объекта в цикле `__iter__` или `__next__` и т. д.

Почти любое действие, которое вам кажется выполняется само собой, скорее всего описано в magic методе.

### init(), new(), del()

При создании (инициализации) объекта вызывается метод `__init__` и помогает нам задать стартовые параметры для нашего
класса.

```python
class A:
    def __init__(self, arg_one, arg_two):
        self.some_arg_one = arg_one
        self.some_arg_two = arg_two


a = A('bla', 22)
a.some_arg_one
# bla
a.some_arg_two
# 22
``` 
Такой способ предпочтительнее, чем вначале задавать какое-то бесполезное значение и сразу же его поменять (номер 
телефона или место на доске из прошлой домашки).

Когда я пишу `x = SomeClass()`, `__init__` не самое первое, что вызывается. На самом деле, экземпляр объекта создаёт 
метод `__new__`, а затем аргументы передаются в инициализатор. На другом конце жизненного цикла объекта находится 
метод `__del__`.

Давайте подробнее рассмотрим эти три магических метода:

`__new__(cls, [...)`

Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые
другие аргументы, которые будут переданы в `__init__`. Метод `__new__` используется весьма редко, но иногда бывает 
полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. 
Я не намерен очень детально останавливаться на `__new__`, так как он не очень часто нужен, и этот метод очень хорошо и
детально описан в документации.

`__init__(self, [...)`

Инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор (так, например, если мы вызываем
`x = SomeClass(10, 'foo')`, `__init__` получит 10 и 'foo' в качестве аргументов. `__init__` почти повсеместно 
используется при определении классов.

`__del__(self)`

Если `__new__` и `__init__` образуют конструктор объекта, то `__del__` - это его деструктор. Он не определяет поведение 
для выражения `del x` (поэтому этот код не эквивалентен `x.__del__()`). Скорее, он определяет поведение объекта в то 
время, когда объект попадает в сборщика мусора. Это может быть довольно удобно для объектов, которые могут требовать
дополнительных чисток во время удаления, таких как сокеты или файловые объекты. Однако, нужно быть осторожным, так как
нет гарантии, что `__del__` будет вызван, если объект продолжает жить, когда интерпретатор завершает работу.
Поэтому `__del__` не может служить заменой для хороших программистских практик (всегда завершать соединение, если
закончил с ним работать и тому подобное). Фактически, из-за отсутствия гарантии вызова `__del__` не должен 
использоваться почти никогда; используйте его с осторожностью.

#### Магические методы сравнения

В Python огромное количество магических методов, созданных для определения интуитивного сравнения между объектами при
помощи операторов, а не плохо выглядящих методов (Что лучше? `a==b` или `a.is_equal(b)` . Кроме того, они предоставляют 
способ переопределить поведение Python по умолчанию для сравнения объектов (по ссылке). Вот список этих методов и что 
они делают:

`__eq__(self, other)`

Определяет поведение оператора равенства, `==`.

`__ne__(self, other)`

Определяет поведение оператора неравенства, `!=`.

`__lt__(self, other)`

Определяет поведение оператора меньше, `<`.

`__gt__(self, other)`

Определяет поведение оператора больше, `>`.

`__le__(self, other)`

Определяет поведение оператора меньше или равно, `<=`.

`__ge__(self, other)`

Определяет поведение оператора больше или равно, `>=`.

Для примера рассмотрим класс, описывающий слово. Мы можем сравнивать слова лексиграфически (по алфавиту), что является
дефолтным поведением при сравнении строк, но можем захотеть использовать при сравнении какой-нибудь другой критерий,
такой как длина или количество слогов. В этом примере мы будем сравнивать по длине. Вот реализация:

```python
class Word(str):
    """Класс для слов, определяющий сравнение по длине слов."""

    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print("Value contains spaces. Truncating to first space.")
            word = word[:word.index(' ')]  # Теперь Word - это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)

    def __lt__(self, other):
        return len(self) < len(other)

    def __ge__(self, other):
        return len(self) >= len(other)

    def __le__(self, other):
        return len(self) <= len(other)

```

Теперь мы можем создать два Word (при помощи Word('foo') и Word('bar')) и сравнить их по длине. Заметьте, что мы не
определяли `__eq__` и `__ne__`, так как это приведёт к странному поведению (например, Word('foo') == Word('bar') будет
расцениваться как истина). В этом нет смысла при тестировании на эквивалентность, основанную на длине, поэтому мы
оставляем стандартную проверку на эквивалентность от str.

### Обычные арифметические операторы

Теперь рассмотрим обычные бинарные операторы (и ещё пару функций): +, -, * и похожие. Они, по большей части, отлично
сами себя описывают.

`__add__(self, other)`

Сложение.

`__sub__(self, other)`

Вычитание.

`__mul__(self, other)`

Умножение.

`__floordiv__(self, other)`

Целочисленное деление, оператор //.

`__div__(self, other)`

Деление, оператор /.

`__mod__(self, other)`

Остаток от деления, оператор %.

`__divmod__(self, other)`

Определяет поведение для встроенной функции `divmod()`.

`__pow__`

Возведение в степень, оператор **.

`__lshift__(self, other)`

Двоичный сдвиг влево, оператор <<.

`__rshift__(self, other)`

Двоичный сдвиг вправо, оператор >>.

`__and__(self, other)`

Двоичное И, оператор &.

`__or__(self, other)`

Двоичное ИЛИ, оператор |.

`__xor__(self, other)`

Двоичный xor, оператор ^.

### Магические методы преобразования типов

Кроме того, в Python множество магических методов, предназначенных для определения поведения для встроенных функций
преобразования типов, таких как `float()`. Вот они все:

`__int__(self)`

Преобразование типа в int.

`__long__(self)`

Преобразование типа в long.

`__float__(self)`

Преобразование типа в float.

`__complex__(self)`

Преобразование типа в комплексное число.

`__oct__(self)`

Преобразование типа в восьмеричное число.

`__hex__(self)`

Преобразование типа в шестнадцатеричное число.

`__index__(self)`

Преобразование типа к int, когда объект используется в срезах (выражения вида [start:stop:step]). Если вы определяете
свой числовой тип, который может использоваться как индекс списка, вы должны определить `__index__`.

`__trunc__(self)`

Вызывается при math.trunc(self). Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long).

`__coerce__(self, other)`

Метод для реализации арифметики с операндами разных типов. `__coerce__` должен вернуть `None`, если преобразование типов
невозможно. Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из `self` и `other`,
преобразованные к одному типу.

### Представление своих классов

Часто бывает полезно представление класса в виде строки. В Python существует несколько методов, которые вы можете
определить для настройки поведения встроенных функций при представлении вашего класса.

`__str__(self)`

Определяет поведение функции str(), вызванной для экземпляра вашего класса.

`__repr__(self)`

Определяет поведение функции repr(), вызванной для экземпляра вашего класса. Главное отличие от `str()` в целевой
аудитории. `repr()` больше предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный
код на Python), а `str()` предназначен для чтения людьми.

`__unicode__(self)`

Определяет поведение функции unicode(), вызванной для экземпляра вашего класса. `unicode()` похож на `str()`, но возвращает
строку в Unicode. Будьте осторожны: если клиент вызывает str() на экземпляре вашего класса, а вы определили только 
`__unicode__()`, то это не будет работать. Постарайтесь всегда определять `__str__()` для случая, когда кто-то не имеет 
такой роскоши как Unicode.

`__format__(self, formatstr)`

Определяет поведение, когда экземпляр вашего класса используется в форматировании строк нового стиля. Например, "Hello,
{0:abc}!".format(a) приведёт к вызову `a.__format__("abc")`. Это может быть полезно для определения ваших собственных
числовых или строковых типов, которым вы можете захотеть предоставить какие-нибудь специальные опции форматирования.

`__hash__(self)`

Определяет поведение функции hash(), вызванной для экземпляра вашего класса. Метод должен возвращать целочисленное
значение, которое будет использоваться для быстрого сравнения ключей в словарях. Заметьте, что в таком случае обычно
нужно определять и `__eq__` тоже. Руководствуйтесь следующим правилом: `a == b` подразумевает `hash(a) == hash(b)`.

`__bool__(self)` (`__nonzero__(self)` в python <  3.0)

Определяет поведение функции bool(), вызванной для экземпляра вашего класса. Должна вернуть True или False, в
зависимости от того, когда вы считаете экземпляр соответствующим True или False.

`__dir__(self)`

Определяет поведение функции dir(), вызванной на экземпляре вашего класса. Этот метод должен возвращать пользователю
список атрибутов. Обычно определение __dir__ не требуется, но может быть жизненно важно для интерактивного
использования вашего класса, если вы переопределили `__getattr__` или `__getattribute__` (с которыми вы встретитесь в
следующей части), или каким-либо другим образом динамически создаёте атрибуты.

`__sizeof__(self)`

Определяет поведение функции sys.getsizeof(), вызванной на экземпляре вашего класса. Метод должен вернуть размер вашего
объекта в байтах. Он полезен для классов, определённых в расширениях на C, но всё-равно полезно о нём знать.

### Протоколы

Протокол для определения неизменяемых контейнеров: чтобы создать неизменяемый контейнер, вы должны только
определить `__len__` и `__getitem__` (подробнее о них дальше). Протокол изменяемого контейнера требует того же, что и
неизменяемого контейнера, плюс `__setitem__` и `__delitem__`. И, наконец, если вы хотите, чтобы ваши объекты можно было
перебирать итерацией, вы должны определить `__iter__`, который возвращает итератор. Этот итератор должен соответствовать
протоколу итератора, который требует методов `__iter__`(возвращает самого себя) и `__next__`.

#### Магия контейнеров

Без дальнейшего промедления вот магические методы, используемые контейнерами:

`__len__(self)`

Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.

`__getitem__(self, key)`

Определяет поведение при доступе к элементу, используя синтаксис `self[key]`. То же относится и к протоколу изменяемых и
к протоколу неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: TypeError, если неправильный тип
ключа, и KeyError, если ключу не соответствует никакого значения.

`__setitem__(self, key, value)`

Определяет поведение при присваивании значения элементу, используя синтаксис `self[nkey] = value`. Часть протокола
изменяемого контейнера. Опять же, вы должны выбрасывать KeyError и TypeError в соответствующих случаях.

`__delitem__(self, key)`

Определяет поведение при удалении элемента (то есть `del self[key]`). Это часть только протокола для изменяемого
контейнера. Вы должны выбрасывать соответствующее исключение, если ключ некорректен.

`__iter__(self)`

Должен вернуть итератор для контейнера. Итераторы возвращаются в множестве ситуаций, главным образом, для встроенной
функции `iter()` и в случае перебора элементов контейнера выражением `for x in container:`. Итераторы сами по себе
объекты и они тоже должны определять метод `__iter__`, который возвращает `self`.

`__reversed__(self)`
Вызывается, чтобы определить поведения для встроенной функции `reversed()`. Должен вернуть обратную версию
последовательности. Реализуйте метод, только если класс упорядоченный, как список или кортеж.

`__contains__(self, item)`

`__contains__` предназначен для проверки принадлежности элемента с помощью `in` и `not in`. Вы спросите, почему же это
не часть протокола последовательности? Потому что когда `__contains__` не определён, Python просто перебирает всю
последовательность элемент за элементом и возвращает True, если находит нужный.

`__next__(self)`

Возвращает следующий объект в последовательности или StopIteration, если больше объектов нет.

### Вызываемые объекты

Как вы, наверное, уже знаете, в Python функции являются объектами первого класса. Это означает, что они могут быть
переданы в функции или методы так же, как любые другие объекты. Это невероятно мощная особенность.

Специальный магический метод позволяет экземплярам вашего класса вести себя так, как будто они функции, то есть вы
сможете «вызывать» их, передавать их в функции, которые принимают функции в качестве аргументов и так далее. Это другая
удобная особенность, которая делает программирование на Python таким приятным.

`__call__(self, [args...])`

Позволяет любому экземпляру вашего класса быть вызванным как будто он функция. Главным образом, это означает, что `x()`
означает то же, что и `x.__call__()`. Заметьте, `__call__()` принимает произвольное число аргументов; то есть вы можете
определить `__call__()` так же как любую другую функцию, принимающую столько аргументов, сколько вам нужно.

`__call__()`, в частности, может быть полезен в классах, чьи экземпляры часто изменяют своё состояние. «Вызвать» 
экземпляр может быть интуитивно понятным и элегантным способом изменить состояние объекта. Примером может быть класс,
представляющий положение некоторого объекта на плоскости:

```python
class Entity:
    """Класс, описывающий объект на плоскости. "Вызываемый", чтобы обновить позицию объекта."""

    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size

    def __call__(self, x, y):
        """Изменить положение объекта."""
        self.x, self.y = x, y
```

На самом деле, magic методов гораздо больше, и вы можете изучить их из документации, если вам необходимо, но практически
любое действие можно переопределить при помощи magic методов.

[Хорошая статья по теме](https://habr.com/ru/post/186608/)
