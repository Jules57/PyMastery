## Функции

_Функция_ - это группа инструкций, которая существует внутри программы с целью выполнения определенной задачи.

Большинство программ выполняет задачи, которые настолько крупные, что их приходится разбивать на несколько подзадач.
Поэтому программисты обычно подразделяют свои программы на небольшие приемлемые порции, которые называются функциями.
Функция — это группа инструкций, которая существует внутри программы с целью выполнения конкретной задачи. Вместо того
чтобы писать большую программу как одну длинную последовательность инструкций, программист создает несколько небольших
функций, каждая из которых выполняет определенную часть задачи. Эти небольшие функции затем могут быть исполнены в
нужном порядке для выполнения общей задачи.

Такой подход иногда называется методом "разделяй и властвуй", потому что большая задача подразделяется на несколько
меньших задач, которые легко выполнить.
Программа, которую пишут так, что каждая подзадача помещается в свою функцию, называется модуляризованной программой.

# Преимущества модуляризации программы на основе функций

В результате разбиения программы на функции она получает следующие преимущества.

- **Более простой код.** Когда код программы разбит на функции, он проще и легче для понимания. Несколько небольших
  функций
  намного легче читать, чем одну длинную последовательность инструкций.
- **Повторное использование кода.** Функции также уменьшают дублирование программного кода в программе. Если
  определенная
  операция в программе выполняется в нескольких местах, то для выполнения этой операции можно один раз написать функцию
  и затем ее исполнять в любое время, когда она понадобится. Это преимущество функций называется повторным
  использованием кода.
- **Более простое тестирование.** Когда каждая задача в программе содержится в собственной функции, процессы
  тестирования и
  отладки становятся проще. Программисты могут индивидуально протестировать каждую функцию в программе и определить,
  выполняет ли она свою задачу правильно. Это упрощает процесс изолирования и исправления ошибок.
- **Более быстрая разработка.** Предположим, что программист или команда программистов разрабатывают многочисленные
  программы. Они обнаруживают, что каждая программа выполняет несколько общих задач, таких как выяснение имени
  пользователя и пароля, вывод текущего времени и т. д. Многократно писать программный код для всех этих задач не
  имеет никакого смысла. Вместо этого для часто встречающихся задач пишут функции, и эти функции могут быть включены в
  состав любой программы, которая в них нуждается.
- **Упрощение командной работы.** Функции также упрощают программистам работу в командах. Когда программа
  разрабатывается
  как набор функций, каждая из которых выполняет отдельную задачу, в этом случае разным программистам может
  быть поручено написание различных функций.

# Функции без возврата значения и с возвратом значения

Есть два типа функций: функции без возврата значения, или пустые функции (void function), и функции с возвратом
значения. Когда вызывается функция без возврата значения, она просто исполняет содержащиеся в ней инструкции и затем
завершается. Когда вызывается функция с возвратом значения, она исполняет содержащиеся в ней инструкции и возвращает
значение в ту инструкцию, которая ее вызвала.

Функция input является примером функции с возвратом значения. При вызове функции input она получает данные, которые
пользователь вводит на клавиатуре, и возвращает эти данные в качестве строкового значения. Функции `int()` и `float()` —
тоже примеры функций с возвратом значения. Вы передаете аргумент функции `int()`, и она возвращает значение этого
аргумента, преобразованное в целое число. Аналогичным образом вы передаете аргумент функции `float()`, и она возвращает
значение этого аргумента, преобразованное в число с плавающей точкой.

Программный код функции называется определением функции. Для исполнения функции пишется инструкция, которая ее вызывает.

Имена функциям назначаются точно так же, как назначаются имена используемым в программе переменным. Имя функции должно
быть достаточно описательным, чтобы любой читающий ваш код мог обоснованно догадаться, что именно функция делает.
Python требует, чтобы вы соблюдали такие же правила, которые вы соблюдаете при именовании переменных:

- в качестве имени функции нельзя использовать одно из ключевых слов Python (см. список ключевых слов);
- имя функции не может содержать пробелы;
- первый символ должен быть одной из букв от a до z, от А до Z либо символом подчеркивания (_);
- после первого символа можно использовать буквы от a до z или от А до Z, цифры от О до 9 либо символы подчеркивания;
- символы в верхнем и нижнем регистрах различаются.
  Поскольку функции выполняют действия, большинство программистов предпочитает в именах функций использовать глаголы.

Примерами хороших имен функций будут get_hours (получить часы), get_pay_rate (получить ставку оплаты труда),
calculate_overtime (рассчитать сверхурочные), print_check (напечатать чек) и т. д. Каждое приведенное выше имя функции
дает описание того, что функция делает.

# Определение и вызов функции

Для того чтобы создать функцию, пишут ее определение. Вот общий формат определения функции в Python:

```python
def имя_функции():
    инструкция
    инструкция
```

Первая строка называется заголовком функции. Он отмечает начало определения функции. Заголовок функции начинается с
ключевого слова def, после которого идет имя_функции, затем круглые скобки и потом двоеточие.

Начиная со следующей строки, идет набор инструкций, который называется блоком. Блок — это просто набор инструкций,
которые составляют одно целое. Эти инструкции исполняются всякий раз, когда функция вызывается. Обратите внимание, что
в приведенном выше общем формате все инструкции в блоке выделены отступом для того, чтобы интерпретатор Python
использовал их для определения начала и конца блока.

Когда функция вызвана, интерпретатор перескакивает к этой функции и исполняет инструкции в ее блоке. Затем, когда
достигнут конец блока, интерпретатор перескакивает назад к той части программы, которая вызвала эту функцию, и программа
возобновляет исполнение в этой точке. Когда это происходит, мы говорим, что функция вернулась.

Начиная со следующей строки, идет набор инструкций, который называется блоком. Блок — это просто набор инструкций,
которые составляют одно целое. Эти инструкции исполняются всякий раз, когда функция вызывается. Обратите внимание, что
в приведенном выше общем формате все инструкции в блоке выделены отступом для того, чтобы интерпретатор Python
использовал их для определения начала и конца блока.

Давайте обратимся к примеру функции.

```python
# Эта программа демонстрирует функцию.
# Сначала мы определяем функцию с именем message. 
def create_message():
    print('Я - Артур,')
    print('король британцев.')


# Вызвать функцию message. 
create_message()
```

Давайте разберем эту программу шаг за шагом и исследуем, что происходит, когда она работает. Сначала интерпретатор
игнорирует комментарии, которые появляются в строках 1 и 2. Затем он читает инструкцию def в строке 3. Она приводит к
тому, что в оперативной памяти создается функция под названием message с блоком инструкций в строках 4 и 5.
(Напомним, что определение функции создает функцию, но оно не исполняет ее.) Далее интерпретатор встречает комментарий
в строке 7, который игнорируется. Затем он исполняет инструкцию в строке 8, которая представляет собой вызов функции.
Эта инструкция приводит к исполнению функции message, которая печатает две строки выходных значений.

Программа имеет всего одну функцию, однако в коде можно определять много функций. Нередко программа имеет главную
функцию main, которая вызывается, когда программа запускается. Функция main по мере надобности вызывает другие функции.
Часто говорится, что функция main содержит стержневую логику программы, т. е. общую логику программы.

Когда программа вызывает функцию, программисты обычно говорят, что поток управления программы передается в эту функцию.
Это просто означает, что функция берет исполнение программы под свой контроль.

В Python каждая строка в блоке должна быть выделена отступом. Последняя выделенная отступом строка после заголовка
функции является последней строкой в блоке функции. В редакторе существует два способа выделить строку отступом:
во-первых, нажатием клавиши <ТаЬ> в начале строки либо, во-вторых, при помощи клавиши <Пробел> для вставки пробелов в
начале строки. При выделении строк отступом в блоке можно использовать либо табуляцию, либо пробелы, но не оба способа
одновременно. В противном случае это может запутать интерпретатор Python и вызвать ошибку.

Пустые строки, которые появляются в блоке, игнорируются.

```python
library = {}


def add_book(title, author):
    """Adds a book to the library."""
    library[title] = author
    print(f"Book '{title}' added to the library.")


def find_author(title):
    """Returns the author of a book by its title."""
    author = library.get(title)
    if author:
        print(f"Author of the book '{title}': {author}.")
    else:
        print(f"Book '{title}' not found in the library.")


def remove_book(title):
    """Removes a book from the library by its title."""
    if title in library:
        del library[title]
        print(f"Book '{title}' removed from the library.")
    else:
        print(f"Book '{title}' not found in the library.")


def show_library():
    """Prints all the books and their authors in the library."""
    if library:
        print("Current collection of the library:")
        for title, author in library.items():
            print(f"- {title} by {author}")
    else:
        print("The library is empty.")


# Demonstration of the functions
add_book("Pride and Prejudice", "Jane Austen")
add_book("1984", "George Orwell")
add_book("Hamlet", "William Shakespeare")
show_library()
find_author("Hamlet")
remove_book("1984")
show_library()

```

# Проектирование программы использованием функций

Для разбиения алгоритма на функции программисты обычно пользуются приемом, который называется нисходящей разработкой
алгоритма или декомпозицией задачи.

Программисты чаще всего применяют метод под названием нисходящей разработки, который позволяет разбивать алгоритм на
функции. Процесс нисходящей разработки алгоритма выполняется следующим образом:

1. Полная задача, которую должна выполнить программа, разбивается на серию подзадач.
2. Каждая подзадача исследуется с целью установления, можно ли ее разложить дальше на другие подзадачи. Этот шаг
   повторяется до тех пор, пока больше ни одной подзадачи невозможно идентифицировать.
3. После того как все подзадачи были идентифицированы, их пишут в программном коде.
   Этот процесс называется нисходящей разработкой, потому что программист начинает с того, что обращается к самому
   верхнему
   уровню выполняемых задач и затем разбивает эти задачи на подзадачи более низкого уровня.

# Использование ключевого слова pass

Приступая к написанию программы, вы знаете имена функций, которые планируете использовать, но еще не представляете всех
деталей кода, который будет в этих функциях. В этом случае вы можете использовать ключевое слово pass для создания
пустых функций. Позже, когда детали кода будут известны, вы можете вернуться к пустым функциям и заменить ключевое
слово pass содержательным кодом.

Ключевое слово pass можно использовать в качестве местозаполнителя в любом месте программного кода Python. Например,
его можно использовать в инструкции if.

# Локальные переменные

**Локальная переменная создается внутри функции**. Инструкции, которые находятся за пределами функции, к ней доступа
не имеют. Разные функции могут иметь локальные переменные с одинаковыми именами, потому что функции не видят локальные
переменные друг друга.

Всякий раз, когда переменной внутри функции присваивается значение, в результате создается локальная переменная. Она
принадлежит функции, в которой создается, и к такой переменной могут получать доступ только инструкции в этой функции.
(Термин "локальный" указывает на то обстоятельство, что переменная может использоваться лишь локально внутри функции,
в которой она создается.)

Если инструкция в одной функции попытается обратиться к локальной переменной, которая принадлежит другой функции, то
произойдет ошибка.

```python

# Определение главной функции. 
def main():
    get_name()


print(f'Hello {name}.')


# Эта инструкция вызовет ошибку!
# Определение функции get_name. 
def get_name():
    name = input('Enter your name: ')


# Вызвать главную функцию. 
main()
```

# Область действия и локальные переменные

_Область действия переменной_ — это часть программы, в которой можно обращаться к переменной. Переменная видима только
инструкциям в области действия переменной. Областью действия переменной является функция, в которой переменная
создается.
Никакая инструкция за пределами функции не может обращаться к такой переменной.
К локальной переменной не может обращаться программный код, который появляется внутри функции в точке до того, как
переменная была создана.
Поскольку локальные переменные функции скрыты от других функций, другие функции могут иметь собственные локальные
переменные с одинаковым именем.

# Передача аргументов в функцию

**Аргумент** — это любая порция данных, которая передается в функцию, когда функция вызывается.

**Параметр** — это переменная, которая получает аргумент, переданный в функцию.

Иногда полезно не только вызвать функцию, но и отправить одну или более порций данных в функцию. Порции данных, которые
отправляются в функцию, называются аргументами. Функция может использовать свои аргументы в вычислениях или других
операциях.

Если требуется, чтобы функция получала аргументы, когда она вызывается, то необходимо оборудовать эту функцию одной или
несколькими параметрическими переменными. Параметрическая переменная, часто именуемая просто параметром, — это
специальная переменная, которой присваивается значение аргумента, когда функция вызывается.

```python
# Это программа демонстрирует аргумент, передаваемый в функцию.
def main():
    value = 5
    show_double(value)


# Функция show_double принимает аргумент # и показывает его удвоенное значение. 
def show_double(number):
    result = number * 2
    print(result)


main()
```

Строка 5 создает локальную переменную с именем value, присваивая ей значение 5. Затем приведенная ниже инструкция в
строке 6 вызывает функцию show double: `show_double(value)`
Обратите внимание, что `value` появляется в круглых скобках. Это означает, что `value` передается в функцию
`show_double` в качестве аргумента. Во время исполнения этой инструкции будет вызвана функция `show_double`, и
параметру `number` будет присвоено то же самое значение, что и в переменной `value`.

Областью действия переменной является часть программы, в которой можно обращаться к этой переменной. Переменная видима
только инструкциям в области действия переменной. Областью действия параметрической переменной является функция,
в которой этот параметр используется. К параметрической переменной могут получать доступ все инструкции внутри функции,
и ни одна инструкция за пределами этой функции к ней доступ получить не может.

Когда аргумент передается в функцию Python, параметрическая переменная функции будет ссылаться на значение этого
аргумента. Однако любые изменения, которые вносятся в параметрическую переменную, не будут влиять на аргумент.

```python
# Эта программа демонстрирует, что происходит, когда вы изменяете значение параметра.
def main():
    value = 99
    print(f'The value is {value}.')
    change_me(value)
    print(f'After returning to the main function, the value becomes {value}.')


def change_me(arg):
    print('I change the value.')
    arg = 0
    print(f'Now the value is {arg}.')


# Вызвать главную функцию.
main()
```

Используемая в Python форма передачи аргументов, в которой функция не может изменять значение переданного ей аргумента,
обычно называется передачей по значению. Эта форма показывает, как одна функция может связываться с другой функцией.
Между тем канал связи работает только в одном направлении: вызывающая функция может связываться с вызванной функцией,
но вызванная функция не может использовать аргумент для связи с вызывающей функцией. Позже вы узнаете,
как написать функцию, способную связываться с частью программы, которая ее вызвала, путем возврата значения.

# Именованные аргументы

Большинство языков программирования таким путем сопоставляют аргументы и параметры функции. В дополнение к этой
стандартной форме передачи параметров язык Python позволяет писать аргумент в приведенном ниже формате, чтобы указывать,
какой параметрической переменной аргумент должен быть передан:

```python
имя_параметра = значение
```

В таком формате _имя_параметра_ — это имя параметрической переменной, а _значение_ — значение, передаваемое в этот
параметр. Аргумент, написанный в соответствии с этой синтаксической конструкцией, называется именованным аргументом.
Поскольку именованный аргумент определяет, в какой параметр этот аргумент должен быть передан, его позиция в вызове
функции не имеет значения.

# Смешивание именованных и позиционных аргументов

В вызове функции имеется возможность смешивать позиционные и именованные аргументы, но при этом позиционные аргументы
должны стоять первыми, после которых идут именованные аргументы. В противном случае произойдет ошибка.

```python
def add_numbers(a=7, b=8):
    total = a + b
    print('Sum:', total)


# function call with two arguments
add_numbers(2, 3)

#  function call with one argument
add_numbers(a=2)

# function call with no arguments
add_numbers()
```

# Распаковка аргументов - *args, **kwargs

В Python есть два мощных механизма для работы с аргументами функций, которые позволяют функциям принимать переменное
количество аргументов. Эти механизмы известны как *args и **kwargs. Они предоставляют гибкость при определении и вызове
функций, делая ваш код более читаемым и эффективным при обработке неопределенного количества аргументов.

`*args` позволяет функции принимать любое количество позиционных аргументов в виде кортежа. Это особенно полезно, когда вы
не знаете заранее, сколько аргументов будет передано вашей функции.

Пример использования *args:

```python
def find_total(*args):
    return sum(args)

print(find_total(1, 2, 3))  
# Вывод: 6
print(find_total(1, 2, 3, 4, 5))  
# Вывод: 15
```

`**kwargs` позволяет функции принимать любое количество именованных аргументов в виде словаря. Это идеально подходит для
ситуаций, когда вы хотите обрабатывать именованные аргументы, которые заранее неизвестны.

Пример использования **kwargs:
```python

def show_info(**kwargs):
    for key, value  in kwargs.items():
        print(f"{key}: {value}")

show_info(name="Will", age=30, city="Jamaica")
```

Вы можете использовать *args и **kwargs вместе, если ваша функция должна принимать как позиционные, так и именованные 
аргументы в переменном количестве.

```python
def foo(*args, **kwargs):
    print("Positional arguments:", args)
    print("Named arguments:", kwargs)

foo(1, 2, 3, name="Will", age=25)
# Вывод:
# Positional arguments: (1, 2, 3)
# Named arguments: {'name': 'Will', 'age': 25}
```

# Глобальные переменные и глобальные константы

Глобальная переменная доступна для всех функций в программном файле.

Вы узнали, что во время создания переменной при помощи инструкции присваивания внутри функции эта переменная является
локальной для этой функции. Следовательно, к ней могут обращаться только инструкции внутри функции, которая ее создала.
Когда переменная создается инструкцией присваивания, написанной за пределами всех функций в программном файле, эта
переменная является глобальной переменной. К глобальной переменной может обращаться любая инструкция в программном
файле, включая инструкции в любой функции.

Если нужно, чтобы инструкция внутри функции присваивала значение глобальной переменной, то требуется дополнительный шаг.
В этом случае, глобальная переменная должна быть объявлена внутри функции.

Большинство программистов соглашаются, что следует ограничить использование глобальных переменных либо не использовать
их вообще. Причины следующие.

- Глобальные переменные затрудняют отладку программы. Значение глобальной переменной может быть изменено любой
  инструкцией в программном файле. Если обнаружится, что в глобальной переменной хранится неверное значение, то придется
  отыскать все инструкции, которые к ней обращаются, чтобы определить, откуда поступает плохое значение. В программе с
  тысячами строк программного кода такая работа может быть сопряжена с большими трудностями.
- Функции, которые используют глобальные переменные, обычно зависят от этих переменных. Если возникнет необходимость
  применить такую функцию в другой программе, то скорее всего придется эту функцию перепроектировать, чтобы она не
  опиралась на глобальную переменную.
- Глобальные переменные затрудняют понимание программы. Глобальная переменная может быть модифицирована любой
  инструкцией в программе. Если возникнет необходимость разобраться в какой-то части программы, которая использует
  глобальную переменную, то придется узнать обо всех других частях программы, которые обращаются к этой глобальной
  переменной.
  В большинстве случаев следует создавать переменные локально и передавать их в качестве аргументов в функции, которым
- нужно к ним обратиться.

# Глобальные константы

Хотя вам следует стараться избегать использования глобальных переменных, в программе допускается применение глобальных
констант. _Глобальная константа_ — это глобальное имя, ссылающееся на значение, которое нельзя изменить. Поскольку
значение
глобальной константы не может быть изменено во время исполнения программы, вам не придется беспокоиться о многих
потенциальных опасностях, которые обычно связаны с использованием глобальных переменных.

Несмотря на то что язык Python не позволяет создавать настоящие глобальные константы, их можно имитировать при помощи
глобальных переменных. Если глобальная переменная не объявляется с использованием ключевого слова `global` внутри
функции, то присвоенное ей значение невозможно изменить внутри этой функции.

# Введение в функции с возвратом значения: генерирование случайных чисел

**Функция с возвратом значения** — это функция, которая возвращает значение обратно в ту часть программы, которая ее
вызвала. Python, а также большинство других языков программирования предоставляют библиотеку заранее написанных функций,
которые выполняют частые задачи. Эти библиотеки, как правило, содержат функцию, которая генерирует случайные числа.

Вы уже узнали о функциях без возврата значения. _Функция без возврата значения_ — это группа инструкций, которая
присутствует в программе с целью выполнения определенной задачи. Когда нужно, чтобы функция выполнила свою задачу, эта
функция вызывается. В результате внутри функции исполняются инструкции. Когда функция завершается, поток управления
программы возвращается к инструкции, которая располагается сразу после вызова функции.

Функция с возвратом значения — это особый тип функций. Она похожа на функцию без возврата значения следующим образом:

- это группа инструкций, которая выполняет определенную задачу;
- когда нужно выполнить функцию, ее вызывают.

Однако когда функция с возвратом значения завершается, она возвращает значение назад в ту часть программы, которая ее
вызвала. Возвращаемое из функции значение используется как любое другое значение: оно может быть присвоено переменной,
выведено на экран, использовано в математическом выражении (если оно является числом) и т. д.

# Функции стандартной библиотеки и инструкция import

Python, а также большинство языков программирования поставляются вместе со стандартной библиотекой функций, которые
были уже написаны за вас. Эти функции, так называемые библиотечные функции, упрощают работу программиста, потому что с
их помощью решаются многие задачи. На самом деле, вы уже применяли несколько библиотечных функций Python. Вот некоторые
из них: `print()`, `input()` и `range()`.

Некоторые библиотечные функции Python встроены в интерпретатор Python. Если требуется применить в программе одну из
таких встроенных функций, нужно просто вызвать эту функцию. Это относится, например, к функциям `print`, `input`,
`range` и другим, с которыми вы уже познакомились. Однако многие функции стандартной библиотеки хранятся в файлах,
которые называются модулями. Эти модули копируются на ваш компьютер при установке языка Python и помогают
систематизировать функции стандартной библиотеки. Например, все функции для выполнения математических операций хранятся
вместе в одном модуле, функции для работы с файлами — в другом модуле и т. д.

Для того чтобы вызвать функцию, которая хранится в модуле, нужно вверху программы написать инструкцию импорта `import`.
Она сообщает интерпретатору имя модуля, который содержит функцию. Например, один из стандартных модулей Python
называется `math`. В нем содержатся различные математические функции, которые работают с числами с плавающей точкой.
Если требуется применить в программе какую-либо функцию из модуля math, необходимо в начале программы написать
инструкцию импорта:

```python
import math


def calculate_circle_area(radius):
    """Calculate and return the area of a circle given its radius."""
    return math.pi * radius ** 2


def calculate_cylinder_volume(radius, height):
    """Calculate the volume of a cylinder using the radius and height.
    This function calls calculate_circle_area to get the base area."""
    base_area = calculate_circle_area(radius)
    return base_area * height


# Example usage
radius = 5
height = 10
circle_area = calculate_circle_area(radius)
cylinder_volume = calculate_cylinder_volume(radius, height)

print(f"Area of the circle: {circle_area:.2f}")
print(f"Volume of the cylinder: {cylinder_volume:.2f}")
```

Эта инструкция приводит к загрузке интерпретатором содержимого математического модуля math в оперативную память и в
результате все функции модуля math становятся доступными в программе.
Поскольку внутреннее устройство библиотечных функций невидимо, многие программисты их рассматривают как черные ящики.
Термин "черный ящик" используется для описания любого механизма, который принимает нечто на входе, выполняет с
полученным на входе некоторую работу (которую невозможно наблюдать) и производит результат на выходе.

Python предлагает несколько библиотечных функций для работы со случайными числами. Эти функции хранятся в модуле
`random` в стандартной библиотеке. Для того чтобы применить любую из этих функций, сначала вверху программы нужно
написать вот эту инструкцию импорта:

```python
import random
```

Данная инструкция приводит к загрузке интерпретатором содержимого модуля random в оперативную память. В результате все
функции модуля `random` становятся доступными в вашей программе.
Первая функция генерации случайного числа, которую мы обсудим, называется `randint()`. Поскольку функция `randint()`
находится в модуле `random`, для обращения к ней в нашей программе потребуется применить специальную форму записи
через точку. В форме записи через точку именем функции будет random.randint. С левой стороны от точки (.) расположено
имя модуля, с правой стороны — имя функции.

Вот пример вызова функции randint:

```python
number = random.randint(1, 100)
```

Обратите внимание, что вызов к функции `randint` появляется на правой стороне от оператора =. Когда функция будет
вызвана, она сгенерирует случайное число в диапазоне от 1 до 100 и затем вернет его. Возвращенное число будет
присвоено переменной `number`

# Вызов функций из f-строки

Вызов функции можно использовать в качестве местозаполнителя в f-строке. Вот пример:

```python
import random

print(f'Value: {random.randint(1, 100)}.')
# Value: 58.
```

F-строки особенно полезны, когда необходимо отформатировать результат вызова функции. Например, приведенная ниже
инструкция выводит случайное число, выровненное по центру в поле шириной 10 символов:

```python
import random

print(f'{random.randint(0, 1000):A10d}')
```

# Написание функций с возвратом значения

Функция с возвратом значения имеет инструкцию `return`, которая возвращает значение в ту часть программы, которая
ее вызвала.

Функцию с возвратом значения пишут точно так же, как и функцию без возврата значения, но с одним исключением: функция
с возвратом значения должна иметь инструкцию return. Вот общий формат определения функции с возвратом значения в Python:

```python
def имя_функции():
    инструкция
    инструкция
    return выражение
```

Значение выражения, которое следует за ключевым словом return, будет отправлено в ту часть программы, которая вызвала
функцию. Это может быть любое значение, переменная либо выражение, которые имеют значение (к примеру,
математическое выражение).

Как использовать функции с возвратом значения?

Функции с возвратом значения предоставляют многие из тех же преимуществ, что имеются у функций без возврата значения:
они упрощают программный код, уменьшают дублирование кода, улучшают ваши возможности по тестированию кода, увеличивают
скорость разработки и способствуют совместной работе в команде.
Поскольку функции с возвратом значения возвращают значение, они могут быть полезными. Например, можно использовать
такую функцию для запроса у пользователя входных данных, и затем она может вернуть введенное пользователем значение.

Возвращение булевых значений
Python позволяет писать булевы функции, которые возвращают либо истину (`True`), либо ложь (`False`). Булеву функцию
можно применять для проверки условия и затем возвращения значения `True` либо `False`, которые будут сигнализировать о
наличии либо отсутствии условия. Булевы функции широко применяются для упрощения сложных условий, которые проверяются в
структурах принятия решения и структурах с повторением.

Возвращение нескольких значений
Примеры функций с возвратом значения, которые мы до сих пор рассматривали, возвращают единственное значение. Однако в
Python вы не ограничены таким вариантом. Как показано в приведенном ниже общем формате, после инструкции `return` можно
определять несколько выражений, разделенных запятыми:

```python
def foo():
    return выражение1, выражение2, ...
```

Возвращение встроенного значения None
Python имеет специальное встроенное значение None, которое используется для указания, что значение отсутствует. Бывает
полезно возвращать из функции значение None, чтобы просигнализировать о произошедшей ошибке.

## Анонимная функция (лямбда-выражение)

В Python лямбда-выражение позволяет создавать анонимные функции - функции, которые не привязаны к имени.

В анонимной функции:

- может содержаться только одно выражение
- могут передаваться сколько угодно аргументов

Стандартная функция:

```python
def sum_arg(a, b):
    return a + b


sum_arg(1, 2)
# 3
```

Аналогичная анонимная функция, или лямбда-функция:

```python
sum_arg = lambda a, b: a + b
sum_arg(1, 2)
# 3
```

Обратите внимание, что в определении лямбда-функции нет оператора `return`, так как в этой функции может быть только
одно выражение, которое всегда возвращает значение и завершает работу функции.

Лямбда-функцию удобно использовать в выражениях, где требуется написать небольшую функцию для обработки данных.

Например, в функции sorted лямбда-выражение можно использовать для указания ключа для сортировки:

```python
list_of_tuples = [('First', 320), ('Second', 99), ('Third', 1010), ('Forth', 11)]

sorted(list_of_tuples, key=lambda x: x[1])
# [('Forth', 11), ('Second', 99), ('First', 320), ('Third', 1010)]
```

```python
max_number = lambda a, b: a if a > b else b
print(max_number(3, 5))
# 5
```
